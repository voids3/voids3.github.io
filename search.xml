<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Codeforces Round #637 (Div. 2)]]></title>
    <url>%2Fvoids3.github.io%2F2020%2F04%2F24%2FCodeforces-Round-637-Div-2%2F</url>
    <content type="text"><![CDATA[A. Nastya and Rice##签到题判断谷物总重量的范围和包重量范围是否有交叉1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;int t,n,a,b,c,d;int main()&#123; cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;n&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d; if(n*(a+b)&lt;c-d || n*(a-b)&gt;c+d)&#123; puts("No"); &#125; else puts("Yes"); &#125; return 0;&#125; B. Nastya and Door题意在[l,l+k-1]范围内寻找山峰的个数最多且l最小 使用前缀和统计[1,i]的山峰个数，然后枚举比较得山峰个数最多且l最小的范围1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 2e5+100;ll t,n,k,a[N],b[N];int main()&#123; cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;n&gt;&gt;k; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; int l=-1,ans=-1,j=0; for(int i=2;i&lt;=n;i++)&#123; if(a[i]&gt;a[i-1]&amp;&amp;a[i]&gt;a[i+1]&amp;&amp;i!=n)&#123; b[i]=b[i-1]; b[i+1]=b[i-1]+1; i++; &#125; else b[i]=b[i-1]; &#125; for(int i=1;i+k-1&lt;=n;i++)&#123; if(b[i+k-1]-b[i+1]&gt;ans)&#123; ans=b[i+k-1]-b[i+1]; l=i; &#125; &#125; cout&lt;&lt;ans+1&lt;&lt;' '&lt;&lt;l&lt;&lt;'\n'; &#125; return 0;&#125; C. Nastya and Strange Generator题意比题难系列：由题中所给规则向一个空数组中添加数，问题中所给的数组是否满足该规则 添加规则r数组本身为空，r[i]表示自身及右边第一个为空的位置count数组如果该位置已经被选过置为0，没被选过表示在r数组中出现的次数假设n=5,r[]={1,2,3,4,5},count[]={1,1,1,1,1}1.向里面添加1，count值都相等，1的位置可以随便选，假设选在3,此时r[]={1,2,4,4,5},count[]={1,1,0,2,1}2.向里面添加2，count[4]最大，所以2的位置选在4，此时r[]={1,2,5,5,5},count[]={1,1,0,0,3}3.向里面添加3，count[5]最大，所以3的位置选在5，此时r[]={1,2,,,},(*表示不存在)，count[]={1,1,0,0,0}4.向里面添加4，count[1]==count[2],所以选1或2都可以,假设选在1，r[]={2,2,,,,},count[]={0,2,0,0,0};显而易见5的位置在第二个最后再结合题目最后所给步骤，可以得出 a[i+1]==a[i]+1,或a[i+1]&lt;a[i] 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5+5;int t,n,a[N];int main()&#123; cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; bool flag=0; int l=a[1]; for(int i=2;i&lt;=n;i++)&#123; if(a[i]&gt;l)&#123; if(a[i]!=a[i-1]+1)&#123; flag=1; break; &#125; else l=a[i]; &#125; else l=a[i]; &#125; if(!flag) puts("Yes"); else puts("No"); &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #636 (Div. 3)]]></title>
    <url>%2Fvoids3.github.io%2F2020%2F04%2F22%2FCodeforces-Round-636-Div-3%2F</url>
    <content type="text"><![CDATA[A. Candies题意:当k&gt;1时输出满足题中所给数列的x值解题思路：等比数列得(2^k-1)x=n,枚举k值即可、Code:12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll t,n;int main()&#123; cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;n; ll k=3; while(1)&#123; if(n%k==0)&#123; cout&lt;&lt;n/k&lt;&lt;endl; break; &#125; k=k*2+1; &#125; &#125; return 0;&#125; B. Balanced Array题意：构建一个长度为n的序列，前n/2全为偶数，后半部分全为奇数，且前后两部分相等 解题思路：当n/2为奇数时，前后两部分和奇偶不同，显然不成立，所以n/2为偶数，其他数从小到大排，最后一个数特别构造即可。 Code: 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll t,n;int main()&#123; cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;n; ll k=n/2; if(k&amp;1) puts("NO"); else &#123; puts("YES"); for(int i=2,j=1;j&lt;=k;i+=2,j++)&#123; cout&lt;&lt;i&lt;&lt;' '; &#125; for(int i=1,j=1;j&lt;k;i+=2,j++)&#123; cout&lt;&lt;i&lt;&lt;' '; &#125; cout&lt;&lt;(n-1)+k&lt;&lt;endl; &#125; &#125; return 0;&#125; C. Alternating Subsequence题意：在序列中找到最长的奇偶相间的子序列，并且该子序列在最长序列中值最大 思路：首先长度优先，其次在每段长度相同的序列中取最大值 Code： 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 2e5+5;ll t,n;ll a[N];int main()&#123; cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i]; ll tmp=a[0],ans=0; for(int i=1;i&lt;n;i++)&#123; if(tmp*a[i]&lt;0)&#123; ans+=tmp; tmp=a[i]; &#125; else&#123; tmp=max(tmp,a[i]); &#125; &#125; cout&lt;&lt;ans+tmp&lt;&lt;endl; &#125; return 0;&#125; D. Constant Palindrome Sum题意：对序列中的元素可以用[1,k]中的数来替换，使1~n/2的所有i都有a[i]+a[n-i+1]=x且x值相等 解题思路：可以假设对于每个x值都需要n次替换，而a[i]+a[n-i+1]取值范围在[2,2*k],计算每对替换一次能得到的最大值最小值；因此对于x值介于最大值最小值之间的只需替换一次，对于其他范围需要替换两次，这时我们可以运用差分将最大值最小值之间的x值替换的次数都减1，而对于不用变换就能得到的也需要减1 Code： 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 2e5+100;ll a[N],cnt[N*2],sub[N*2];ll t,n,k;int main()&#123; cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;n&gt;&gt;k; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; for(int i=2;i&lt;=2*k;i++) cnt[i]=n,sub[i]=0;//每一对都初始化为2次，初始化差分数组 for(int i=1;i&lt;=n/2;i++)&#123; ll x=a[i],y=a[n-i+1]; ll mi=min(x,y)+1,mx=max(x,y)+k; cnt[x+y]--;//不用变换的值减1 sub[mi]--;sub[mx+1]++;//对区间[mi,mx]之间的x值都减1 &#125; ll ans=0x3f3f3f3f; for(int i=2;i&lt;=2*k;i++)&#123; sub[i]+=sub[i-1];//前缀和 cnt[i]+=sub[i]; ans=min(ans,cnt[i]); &#125; cout&lt;&lt;ans&lt;&lt;'\n'; &#125; return 0;&#125; E. Weights Distributing题意：找到a-&gt;b-&gt;c的最短花费 解题思路：找中间点a-&gt;x-&gt;b-&gt;x-&gt;c，可以看出b-&gt;x这条边计算两次，所以它的权值应该最小。 从1~n枚举x，然后计算a,b,c到x点的边数，最后找最小值即可 Code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 2e5+100,INF=0x3f3f3f3f;ll p[N],sum[N];int t,n,m,a,b,c;vector&lt;int&gt;g[N];void bfs(int x,vector&lt;int&gt;&amp;d)&#123; d[x]=0; queue&lt;int&gt;q; q.push(x); while(!q.empty())&#123; int p=q.front(); q.pop(); for(int i=0;i&lt;g[p].size();i++)&#123; int v=g[p][i]; if(d[v]==INF)&#123; d[v]=d[p]+1; q.push(v); &#125; &#125; &#125;&#125;int main()&#123; cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;a&gt;&gt;b&gt;&gt;c; for(int i=1;i&lt;=n;i++) g[i].clear(); for(int i=1;i&lt;=m;i++) cin&gt;&gt;p[i]; sort(p+1,p+m+1); for(int i=0;i&lt;m;i++)&#123; int x,y; cin&gt;&gt;x&gt;&gt;y; g[x].push_back(y); g[y].push_back(x); &#125; vector&lt;int&gt;da(n+1,INF),db(n+1,INF),dc(n+1,INF); bfs(a,da);bfs(b,db);bfs(c,dc);//da表示a到每个点的边数 memset(sum,0,sizeof(sum)); for(int i=1;i&lt;=m;i++)&#123;//前i条边的和 sum[i]=sum[i-1]+p[i]; &#125; ll ans=1e18; for(int i=1;i&lt;=n;i++)&#123;// cout&lt;&lt;da[i]+db[i]+dc[i]&lt;&lt;endl; if(da[i]+db[i]+dc[i]&lt;=m)&#123; ans=min(ans,sum[db[i]]+sum[da[i]+db[i]+dc[i]]); &#125; &#125; cout&lt;&lt;ans&lt;&lt;'\n'; &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #630 (Div. 2)]]></title>
    <url>%2Fvoids3.github.io%2F2020%2F04%2F01%2FCodeforces-Round-630-Div-2%2F</url>
    <content type="text"><![CDATA[题目链接：https://codeforces.com/contest/1332A. Exercising Walk题意：在题目所给次数反复左右上下跳过程中不超过题目所给范围Code:123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1e5+5;typedef long long ll;int t,a,b,c,d,x,y,x1,x2,y1,y2;int main()&#123; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d; cin&gt;&gt;x&gt;&gt;y&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2; if(x==x1 &amp;&amp; x1==x2 &amp;&amp; (a||b)) &#123; puts("No"); continue; &#125; if(y==y1 &amp;&amp; y==y2 &amp;&amp; (c||d)) &#123; puts("No"); continue; &#125; if(a&gt;=b) a=a-b,b=0; else b=b-a,a=0; if(c&gt;=d) c=c-d,d=0; else d=d-c,c=0; if(x-x1&gt;=a&amp;&amp;x2-x&gt;=b&amp;&amp;y-y1&gt;=c&amp;&amp;y2-y&gt;=d) puts("Yes"); else puts("No"); &#125; return 0; &#125; B. Composite Coloring题意：将所给数字都染上颜色，两个数字能被染上相同数字的条件是gcd&gt;1,且颜色最大不能超过11 解题思路:分解质因数，不用将颜色的数量控制在最小 Code: 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1e5+5;typedef long long ll;int t,n,a[N],ans[N];int b[N];int main()&#123; cin&gt;&gt;t; while(t--) &#123; memset(b,0,sizeof(b)); cin&gt;&gt;n; int l=1; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;a[i]; for(int j=2;j*j&lt;=a[i];j++)&#123; if(a[i]%j==0)&#123; if(b[j]) ans[i]=b[j]; else ans[i]=b[j]=l++; break; &#125; &#125; &#125; cout&lt;&lt;--l&lt;&lt;endl; for(int i=0;i&lt;n;i++)&#123; cout&lt;&lt;ans[i]&lt;&lt;' '; &#125; cout&lt;&lt;endl; &#125; return 0; &#125; C. K-Complete Word题意：给你一个字符串，要保证这个字符串本身是回文且是以k个字符为一个周期的字符串，求对字符最小改动次数使字符串满足条件 解题思路：这个字符串是以一个周期的一半复制颠倒而成的，然后从半个周期枚举整个字符串的情况，求最小改动次数即可 Code： 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;const int N=200010;typedef long long ll;int t,n,k,m;int a[N],c[N];int ans[27];string s;int main()&#123; cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;n&gt;&gt;k&gt;&gt;s; int res=0; for(int i=0;i&lt;(k+1)/2;i++)&#123; memset(ans,0,sizeof(ans)); for(int j=i;j&lt;n;j+=k)&#123;//其他周期 ans[s[j]-'a']++; &#125; if(k-i-1 != i)&#123; for(int j=k-i-1;j&lt;n;j+=k)&#123; //另外半个周期加其对应的其他周期 ans[s[j]-'a']++; &#125; &#125; int m=*max_element(ans,ans+26);//求数组中的最大值 int sum=accumulate(ans,ans+26,0);//计算数组的和 res+=sum-m; &#125; cout&lt;&lt;res&lt;&lt;endl; &#125; return 0; &#125; D. Walk on Matrix题意：求最优解法和dp解法的差是k所满足的矩阵 解题思路：使dp路径答案为0，最优路径为k(大佬的代码,先贴出来，明天再看) 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;const int N=200010;typedef long long ll;int t,n,k,m;int a[N],c[N];char s[N];int main()&#123; cin&gt;&gt;n; for(int i=0;i&lt;20 &amp;&amp; (m+(1&lt;&lt;i)&lt;3e5);i++) &#123; m+=(1&lt;&lt;i); if((n&amp;(1&lt;&lt;i))==0&amp;&amp;k+(1&lt;&lt;i)&lt;3e5)&#123; k+=(1&lt;&lt;i); &#125; &#125; cout&lt;&lt;2&lt;&lt;' '&lt;&lt;3&lt;&lt;endl; cout&lt;&lt;m&lt;&lt;' '&lt;&lt;k&lt;&lt;' '&lt;&lt;0&lt;&lt;endl; cout&lt;&lt;n&lt;&lt;' '&lt;&lt;m&lt;&lt;' '&lt;&lt;n; return 0; &#125;]]></content>
      <tags>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #629 (Div. 3)]]></title>
    <url>%2Fvoids3.github.io%2F2020%2F03%2F27%2FCodeforces-Round-629-Div-3%2F</url>
    <content type="text"><![CDATA[A. Divisibility Problem判断a是否是b的倍数，不是计算比a大的b的倍数比a大多少Code:1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 1e5+5,mod=998244353;vector&lt;int&gt;ve[N];ll t,a,b;int main()&#123; cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;a&gt;&gt;b; if(a%b==0)&#123; cout&lt;&lt;0&lt;&lt;endl; &#125; else&#123; cout&lt;&lt;(a/b+1)*b-a&lt;&lt;endl; &#125; &#125; return 0;&#125; B. K-th Beautiful String链接：https://codeforces.com/contest/1328/problem/B 观察第一个b移动时k的取值，相邻移动差成等差数列 Code: 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 1e5+5,mod=998244353;int a[N],b[N];string s;ll t,n,k;map&lt;int,int&gt;mp;void solve()&#123; cin&gt;&gt;n&gt;&gt;k; ll sum=1,step=1,l=n-2; while(sum+step&lt;=k)&#123; sum+=step++; l--; &#125; k-=sum; string s=string(n,'a'); s[l]=s[n-1-k]='b'; cout&lt;&lt;s&lt;&lt;endl;&#125;int main()&#123; cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125; C. Ternary XOR第i位为2则都为1,第i位为1将1给第一个，后面的1,2都给第二个 Code: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 1e5+5,mod=998244353;char a[N],b[N];string s;ll t,n,k;int main()&#123; cin&gt;&gt;t; while(t--)&#123; memset(a,0,sizeof(a)); memset(b,0,sizeof(b)); cin&gt;&gt;n; cin&gt;&gt;s; int len = s.length(); bool flag=0; for(int i=0;i&lt;len;i++)&#123; if(s[i]=='2')&#123; if(!flag)&#123; a[i]=b[i]='1'; &#125; else &#123; a[i]='0'; b[i]='2'; &#125; &#125; else if(s[i]=='1')&#123; if(!flag)&#123; a[i]='1'; flag=1; b[i]='0'; &#125; else &#123; a[i]='0'; b[i]='1'; &#125; &#125; else a[i]=b[i]='0'; &#125; cout&lt;&lt;a&lt;&lt;'\n'&lt;&lt;b&lt;&lt;endl; &#125; return 0;&#125; D. Carousel链接：https://codeforces.com/contest/1328/problem/D 题意: 意思很简单，相邻两个不同类型的动物颜色不能相同，因为是环，所以头尾不能相同，比赛时没想明白，可以分成3种情况 1.都是同种动物都为12.如果n为偶数,颜色2种,12121212…即可3.如果n为奇数,如果中间有相邻同类型的动物，将颜色从中间断开即可,如果不存在,随便一个3，剩余1212..即可 Code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 1e5+5,mod=998244353;int a[N],b[N];string s;ll t,n,k;map&lt;int,int&gt;mp;void solve()&#123; cin&gt;&gt;n; int a[n];for(int &amp;i:a) cin&gt;&gt;i; int res[n]=&#123;&#125;; bool flag=1; for(int i=1;i&lt;n;i++) if(a[i]!=a[i-1]) flag=0; if(flag)&#123; fill(res,res+n,1); &#125; else if(n%2==0)&#123; for(int i=0;i&lt;n;i++) res[i]=(i&amp;1?1:2); &#125; else &#123; for(int i=0;i&lt;n;i++)&#123; if(a[i]==a[(i+1)%n])&#123; for(int j=i-1;j&gt;=0;j--) res[j]=(j&amp;1?1:2); for(int j=i+2;j&lt;n;j++) res[j]=(j&amp;1?2:1); res[i]=res[(i+1)%n]=(i&amp;1?1:2); break; &#125; &#125; &#125; if(res[0]==0)&#123; res[0]=3; for(int i=1;i&lt;n;i++) res[i]=(i&amp;1?1:2); &#125; cout&lt;&lt;*max_element(res,res+n)&lt;&lt;'\n'; for(int i=0;i&lt;n;i++) cout&lt;&lt;res[i]&lt;&lt;" \n"[i==n-1];&#125;int main()&#123; cin&gt;&gt;t; while(t--)&#123; solve(); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 84 (Rated for Div. 2)]]></title>
    <url>%2Fvoids3.github.io%2F2020%2F03%2F24%2FEducational-Codeforces-Round-84-Rated-for-Div-2%2F</url>
    <content type="text"><![CDATA[A. Sum of Odd Integers题意：两个数n、k,判断n是否能被产分成k个不同的素数解题思路：首先n，k奇偶性要相同，然后根据求和公式k个奇数相加最小数为k^2,故n&gt;=k^2Code:1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll t,n,k; //注意范围int main()&#123; cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;n&gt;&gt;k; if(n%2 == k%2 &amp;&amp; n&gt;=k*k)&#123; puts("YES"); &#125; else &#123; puts("NO"); &#125; &#125; return 0;&#125; B. Princesses and Princes题意：有n个公主每人都有个名单，每个公主依次从名单上找到数最小并且未被选走的王子，如果最后公主有剩余则在某个公主的名单上添加一个未被选走的王子 解题思路：对已选走的王子及剩余的公主都进行标记，然后搭配即可 Code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 1e5+5,mod=998244353;vector&lt;int&gt;ve[N];int t,n,vis[N];int main()&#123; cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;n;// vector&lt;int&gt;ve[N]; for(int i=1;i&lt;=n;i++)&#123; ve[i].clear(); int k; cin&gt;&gt;k; for(int j=1;j&lt;=k;j++)&#123; int x; cin&gt;&gt;x; ve[i].push_back(x); &#125; &#125; memset(vis,0,sizeof(vis)); int temp=-1,flag=0; for(int i=1;i&lt;=n;i++)&#123; flag=0; for(int j=0;j&lt;ve[i].size();j++)&#123; if(!vis[ve[i][j]])&#123; flag=1; vis[ve[i][j]]=1; break; &#125; &#125; if(!flag)&#123; temp=i; &#125; &#125; if(temp==-1)&#123; cout&lt;&lt;"OPTIMAL"&lt;&lt;endl; &#125; else &#123; for(int i=1;i&lt;=n;i++)&#123; if(!vis[i])&#123; cout&lt;&lt;"IMPROVE"&lt;&lt;endl; cout&lt;&lt;temp&lt;&lt;' '&lt;&lt;i&lt;&lt;endl; break; &#125; &#125; &#125; &#125; return 0;&#125; C. Game with Chips题目链接：https://codeforces.com/contest/1327/problem/C 题目大意：n*m方格中有k个卡牌，每个卡牌有初始位置及需要经过一次的位置，如果能到达则给出路径，否则输出-1，每次移动所有卡牌都要移动，到边界位置后卡牌不再移动 解题思路：先将卡牌一道到（1，1）位置，然后按行小优先原则依次移动，考虑最坏情况移动次数为2(n-1)(m-1)&lt;2nm; Code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=500;int t,n,m,k;string s;struct node&#123; int x,y;&#125;eg[N];bool cmp(node a,node b)&#123; if (a.x==b.x) return a.y&lt;b.y; else return a.x&lt;b.x;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; for(int i=1;i&lt;m;i++) s.push_back('L'); for(int i=1;i&lt;n;i++) s.push_back('U'); int x,y; for(int i=0;i&lt;k;i++) cin&gt;&gt;x&gt;&gt;y; for(int i=1;i&lt;=k;i++) &#123; cin&gt;&gt;eg[i].x&gt;&gt;eg[i].y; &#125; eg[0]=&#123;1,1&#125;; sort(eg,eg+k+1,cmp); for(int i=1;i&lt;=k;i++) &#123; int num1=abs(eg[i].x-eg[i-1].x); int num2=abs(eg[i].y-eg[i-1].y); if(eg[i].x&gt;=eg[i-1].x) &#123; for(int j=0;j&lt;num1;j++) s.push_back('D'); &#125; else &#123; for(int j=0;j&lt;num1;j++) s.push_back('U'); &#125; if(eg[i].y&gt;=eg[i-1].y) &#123; for(int j=0;j&lt;num2;j++) s.push_back('R'); &#125; else &#123; for(int j=0;j&lt;num2;j++) s.push_back('L'); &#125; &#125; if(s.size()&lt;=2*n*m)&#123; cout&lt;&lt;s.size()&lt;&lt;endl&lt;&lt;s; &#125; else cout&lt;&lt;"-1"&lt;&lt;endl; return 0; &#125; E. Count The Blocks链接：https://codeforces.com/contest/1327/problem/E 题意：求0 ~ 10^n - 1中数目为1~n的块数 思路：假设num为i长度的块 1.num位于中间，放的方法有(n-i-1)种，则num前后的数都与num不同，都有9种可能，剩下的(n-i-2)个位置都有10种可能，num本身有10种 2.num位于边界，num前或后的数放的方法有9种，剩下的(n-i-1)都有10种可能，num本身10种可能 3.num长为1，只有一种方法，本身10种可能 Code: 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 100,mod=998244353;int n;ll ksm(ll a,ll b)&#123; ll res=1; while(b&gt;0)&#123; //注意b可能小于0 if(b&amp;1) res=res*a%mod; b&gt;&gt;=1; a=a*a%mod; &#125; return res;&#125;int main()&#123; cin&gt;&gt;n; for(ll i=1;i&lt;n;i++)&#123; ll sum=0; sum=(sum+(n-i-1)*9*9*10*ksm(10,n-i-2))%mod;//中间情况 sum=(sum+2*9*ksm(10,n-i-1)*10)%mod;//边界情况 cout&lt;&lt;sum&lt;&lt;" "; &#125; cout&lt;&lt;10&lt;&lt;endl; return 0;&#125; 剩下的都是有生之年系列]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Global Round 7]]></title>
    <url>%2Fvoids3.github.io%2F2020%2F03%2F20%2FCodeforces-Global-Round-7%2F</url>
    <content type="text"><![CDATA[#A. Bad Ugly Numbers题目大意：给你一个数字n你需要找到一个满足以下条件的数字s： 1.s大于0 2.s有n位数字 3.s任一位上不包括0 4.s不能被任意位上的数整除解题思路：可以发现s用两个质数组成可以满足上述条件Code: 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;int t,n;int main()&#123; cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;n; if(n==1) cout&lt;&lt;-1&lt;&lt;endl; else &#123; if((2*(n-1)+3)%3==0)&#123; for(int i=1;i&lt;=n-2;i++) cout&lt;&lt;2; cout&lt;&lt;33&lt;&lt;endl; &#125; else &#123; for(int i=1;i&lt;n;i++) cout&lt;&lt;2; cout&lt;&lt;3&lt;&lt;endl; &#125; &#125; &#125; return 0;&#125; B. Maximums 题目大意：三个数组，a，x，b，x[i]是a[1 ~ i-1]的最大值，b[i]=a[i]-x[i],给你b数组，求a数组 解题思路：因为x[1]=0,所以a[1]=b[1],故可由b数组推出x数组然后推出a数组 Code： 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5+5;int t,n,b[N],a[N],x[N];int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;b[i]; x[1]=0;a[1]=b[1]; int maxx=a[1],pos=1; for(int i=2;i&lt;=n;i++)&#123; a[i]=b[i]+maxx; if(a[i]&gt;maxx)&#123; maxx=a[i]; pos=i; &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; cout&lt;&lt;a[i]&lt;&lt;' '; &#125; cout&lt;&lt;endl; return 0;&#125; C. Permutation Partitions 题目链接：https://codeforces.com/contest/1326/problem/C 题目大意：给你一个由1~n组成的数组a[n],将数组分成k块，使每块的最大值最大，问最大值是多少和分法种数 解题思路：分成k块其实就是将n~n-k+1这几个数字放入k个区间，类似于高中排列组合的插板问题,将板子插到所要找的数字间就好了 Code： 1234567891011121314151617181920212223#include&lt;iostream&gt;using namespace std;typedef long long ll;const int mod=998244353;int n,k,x;ll ans=1,sum,p=-1;int main()&#123; cin&gt;&gt;n&gt;&gt;k; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;x; if(x&gt;=(n-k+1))&#123; sum+=x; if(p!=-1)&#123; ans=ans*(i-p)%mod; &#125; p=i; &#125; &#125; cout&lt;&lt;sum&lt;&lt;" "&lt;&lt;ans; return 0;&#125; D1. Prefix-Suffix Palindrome (Easy version) 题目链接：https://codeforces.com/contest/1326/problem/D1 题目大意：给你一个字符串s，找到前后缀使a+b是回文串且最长 解题思路：简单的我们可以模拟一下 Code: 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;bool ok(const string &amp;s,int l,int r)&#123; while(l&lt;=r&amp;&amp;s[l]==s[r]) ++l,--r; return l&gt;r;&#125;void solve()&#123; string s;cin&gt;&gt;s; int l=0,r=s.size()-1; while(l&lt;r&amp;&amp;s[l]==s[r]) ++l,--r; int r2,l2; for(r2=r;r2&gt;=l;r2--) if(ok(s,l,r2)) break; for(l2=l;l2&lt;=r;l2++) if(ok(s,l2,r)) break; cout&lt;&lt;s.substr(0,l) &lt;&lt;((r2-l&gt;r-l2)?s.substr(l,r2-l+1):s.substr(l2,r-l2+1)) &lt;&lt;s.substr(r+1) &lt;&lt;"\n";&#125;int main()&#123; int t;cin&gt;&gt;t; while(t--) solve(); return 0;&#125; D2. Prefix-Suffix Palindrome (Hard version) 题目链接：https://codeforces.com/contest/1326/problem/D2 题目大意：和D1一样只是范围大了 解题思路：先首尾找到最长匹配的l，r；然后再取剩下字符串的较长的回文前缀或回文后缀 KMP： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;int n;string s;vector&lt;int&gt;cal_nxt(string s)&#123; int n=s.length(); vector&lt;int&gt;nxt(n); for(int i=1;i&lt;n;i++)&#123; int j=nxt[i-1]; while(j&amp;&amp;s[i]!=s[j])&#123; j=nxt[j-1]; &#125; if(s[i]==s[j]) nxt[i]=++j; &#125; return nxt;&#125;int main()&#123; cin&gt;&gt;n; while(n--)&#123; cin&gt;&gt;s; int len = s.length(); int i=0,j=len-1; while(i&lt;j&amp;&amp;s[i]==s[j]) i++,j--; string s1=s.substr(i,j-i+1); string s2=s1; reverse(s2.begin(),s2.end()); vector&lt;int&gt;nxt1=cal_nxt(s1+"#"+s2); vector&lt;int&gt;nxt2=cal_nxt(s2+"#"+s1); int len2=s1.size()+1+s2.size();// cout&lt;&lt;j+1&lt;&lt;endl;// cout&lt;&lt;nxt1[len2-1]&lt;&lt;' '&lt;&lt;nxt2[len2-1]&lt;&lt;endl; if(nxt1[len2-1]&gt;=nxt2[len2-1])&#123; cout&lt;&lt;s.substr(0,i)&lt;&lt;s1.substr(0,nxt1[len2-1])&lt;&lt;s.substr(j+1,len-j+1)&lt;&lt;endl; &#125; else &#123; cout&lt;&lt;s.substr(0,i)&lt;&lt;s2.substr(0,nxt2[len2-1])&lt;&lt;s.substr(j+1,len-j+1)&lt;&lt;endl; &#125; &#125; return 0;&#125; 字符串哈希：这个还是蛮坎坷的，按yxc大佬的模除2^64wa4，base=131 wa110,按我的写法ss==””,时也会输出一个空格。我太难了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;using namespace std;int n;string s;typedef long long ll;typedef unsigned long long ull;const ll N = 1e6+5,base=113,mod=1e9+7;ull p[N];void init()&#123; p[0]=1; for(int i=1;i&lt;N;i++)&#123; p[i]=p[i-1]*base%mod; &#125;&#125;int main()&#123; init(); cin&gt;&gt;n; while(n--)&#123; cin&gt;&gt;s; int len = s.length(); int l=0,r=len-1; while(l&lt;r&amp;&amp;s[l]==s[r]) l++,r--; string ss=s.substr(l,r-l+1); string tt=ss; reverse(tt.begin(),tt.end()); int len1=ss.size(); ll res1=0,res2=0; int ans1=0,ans2=0; for(int i=0;i&lt;len1;i++)&#123; res1=(res1+p[i]*(ss[i]-'a')%mod)%mod; res2=(res2*base+(ss[i]-'a'))%mod; if(res1==res2) ans1=i; &#125; res1=0,res2=0; for(int i=0;i&lt;len1;i++)&#123; res1=(res1+p[i]*(tt[i]-'a')%mod)%mod; res2=(res2*base+(tt[i]-'a'))%mod; if(res1==res2) ans2=i; &#125;// if(ans1==0) ss="";// if(ans2==0) tt=""; for(int i=0;i&lt;l;i++) cout&lt;&lt;s[i]; if(ans1&gt;=ans2)&#123; if(ss!="")for(int i=0;i&lt;=ans1;i++) cout&lt;&lt;ss[i]; &#125; else &#123; if(tt!="")for(int i=0;i&lt;=ans2;i++) cout&lt;&lt;tt[i]; &#125; for(int i=r+1;i&lt;len;i++) cout&lt;&lt;s[i]; cout&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #618]]></title>
    <url>%2Fvoids3.github.io%2F2020%2F02%2F10%2FCodeforces-Round-618%2F</url>
    <content type="text"><![CDATA[C. Anu Has a Function题目链接：https://codeforces.com/contest/1300/problem/C、题目大意：给你一个数组，问按怎样的顺序进行题中所给式子运算使结果最大，输出顺序解题思路：把数组中每一个数转化为二进制存储，然后对于每两个二进制数的每一位进行所给式子运算，得到规律：f(1,1) = 1|1-1=0;f(1,0) = 1|0-0=1;f(0,1) = 0|1-1=0;f(0,0) = 0|0-0=0;发现只有f(1,0)的1会被保留下来，所以需要挑选运算过程中会被保留下来的数放在最前面，从最高位开始比较，而32位足够存储范围在1e9以内的数,如果没有这样的数，随便输出就行 Code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int N = 1e5+5;ll a[N],b[N][32],n;map&lt;ll,ll&gt;ma;int main()&#123; cin&gt;&gt;n; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;a[i]; ll x=a[i]; for(int j=0;j&lt;32;j++)&#123;//转化为二进制 b[i][j]=x%2; x/=2; &#125; &#125; ll sum=0,pos=-1; bool flag=0; for(int i=31;i&gt;=0;i--)&#123;//从最高位开始比较 sum=0; for(int j=0;j&lt;n;j++)&#123; if(b[j][i]==1) &#123; sum++,pos=j; &#125; &#125; if(sum==1)&#123; sum=0; flag=1; cout&lt;&lt;a[pos]&lt;&lt;' '; break; &#125; &#125; for(int i=0;i&lt;n;i++)&#123; if(i==pos&amp;&amp;flag) continue; else cout&lt;&lt;a[i]&lt;&lt;' '; &#125; return 0;&#125; D. Aerodynamic题目链接：https://codeforces.com/contest/1300/problem/D 题目大意：给你一个p图形，然后p图形在平面内平移，只要包含原点就行，T图形包含所有平移的可能，问p，T图形是否相似 解题思路：判断是否为中心对称图形即可 Code: 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;using namespace std;const int N = 1e5+5;typedef long long ll;int n;struct node&#123; ll x,y;&#125;eg[N];int main()&#123; cin&gt;&gt;n; if(n&amp;1)&#123; puts("NO"); return 0; &#125; double midx=0,midy=0; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;eg[i].x&gt;&gt;eg[i].y; midx+=eg[i].x;midy+=eg[i].y; &#125; midx/=n,midy/=n; int num=n/2; for(int i=1;i&lt;=num;i++)&#123; if((eg[i].x+eg[i+num].x)*0.5!=midx || (eg[i].y+eg[i+num].y)*0.5!=midy)&#123; puts("No"); return 0; &#125; &#125; puts("YES"); return 0;&#125;]]></content>
      <categories>
        <category>CF</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[差分]]></title>
    <url>%2Fvoids3.github.io%2F2020%2F02%2F04%2F%E5%B7%AE%E5%88%86%2F</url>
    <content type="text"><![CDATA[题目链接：https://www.acwing.com/problem/content/description/799/一维差分：Code:123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int N = 1e5+5;int a[N],b[N];int n,m,l,r,c;void insert(int l,int r,int c)&#123; b[l]+=c; b[r+1]-=c;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i]; insert(i,i,a[i]); //初始化差分数组 &#125; while(m--)&#123; cin&gt;&gt;l&gt;&gt;r&gt;&gt;c; insert(l,r,c); &#125; for(int i=1;i&lt;=n;i++)&#123; a[i]=a[i-1]+b[i]; cout&lt;&lt;a[i]&lt;&lt;' '; &#125; cout&lt;&lt;'\n'; return 0;&#125; 二维差分： Code: 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;using namespace std;const int N = 1500;int a[N][N],b[N][N];int n,m,q;void insert(int x1,int y1,int x2,int y2,int c)&#123; b[x1][y1]+=c; b[x2+1][y1]-=c; b[x1][y2+1]-=c; b[x2+1][y2+1]+=c;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;q; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++) &#123; cin&gt;&gt;a[i][j]; insert(i,j,i,j,a[i][j]); &#125; &#125; while(q--)&#123; int x1,y1,x2,y2,c; cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2&gt;&gt;c; insert(x1,y1,x2,y2,c); &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; a[i][j]=b[i][j]+a[i-1][j]+a[i][j-1]-a[i-1][j-1]; cout&lt;&lt;a[i][j]&lt;&lt;' '; &#125; cout&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树状数组与线段树]]></title>
    <url>%2Fvoids3.github.io%2F2020%2F02%2F04%2F%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E4%B8%8E%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[动态求连续区间和题目链接：https://www.acwing.com/problem/content/description/1266/解题思路：板子题树状数组解法：12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int N = 1e5+5;int a[N],tr[N];int n,m,k,x,y;int lowbit(int x)&#123; //二进制x最低位1所对应的值 return x&amp;-x;&#125;void add(int x,int v)&#123; //在某一位加v for(int i=x;i&lt;=n;i+=lowbit(i))&#123; tr[i]+=v; &#125;&#125;int query(int x)&#123; //求1~x数组的和 int res=0; for(int i=x;i;i-=lowbit(i))&#123; res+=tr[i]; &#125; return res;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i]; add(i,a[i]); //初始化树状数组 &#125; while(m--)&#123; cin&gt;&gt;k&gt;&gt;x&gt;&gt;y; if(k) add(x,y); else cout&lt;&lt;query(y)-query(x-1)&lt;&lt;endl; &#125; return 0;&#125; 线段树代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int N = 4e5+10;int a[N];int n,m,k,x,y;struct &#123; int l,r,sum;&#125;tr[N];void pushup(int u)&#123;//左右子树的和 tr[u].sum=tr[u*2].sum+tr[u*2+1].sum;&#125;void build(int u,int l,int r)&#123;//建立线段树 if(l==r) tr[u]=&#123;l,r,a[l]&#125;; else &#123; tr[u]=&#123;l,r&#125;;//初始化 int mid = (l+r) &gt;&gt; 1; build(u*2,l,mid); build(u*2+1,mid+1,r); pushup(u); &#125;&#125;void modify(int u,int x,int v)&#123;//更新线段树 if(tr[u].l==tr[u].r) tr[u].sum+=v; else &#123; int mid=(tr[u].l+tr[u].r)&gt;&gt;1; if(x&gt;mid) modify(u*2+1,x,v); else modify(u*2,x,v); pushup(u); &#125;&#125;int query(int u,int l,int r)&#123;//求l~r数组的和 if(l&lt;=tr[u].l&amp;&amp;r&gt;=tr[u].r) return tr[u].sum; int sum=0; int mid=(tr[u].l+tr[u].r)&gt;&gt;1; if(l&lt;=mid) sum+=query(u*2,l,r); if(r&gt;mid) sum+=query(u*2+1,l,r); return sum;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; build(1,1,n); while(m--)&#123; cin&gt;&gt;k&gt;&gt;x&gt;&gt;y; if(k) modify(1,x,y); else cout&lt;&lt;query(1,x,y)&lt;&lt;endl; &#125; return 0;&#125; 数星星题目链接：https://www.acwing.com/problem/content/description/1267/ 解题思路：坐标按纵坐标升序给出，求当前星星左下方的星星个数只会在已经给出的坐标中，在已出现的坐标中统计坐标为x的星星个数，再求前缀和即可 Code： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 1e5;int a[N],tr[N];int n,x,y;int lowbit(int x)&#123; return x&amp;(-x);&#125;void add(int x,int v)&#123; for(int i=x;i&lt;=32001;i+=lowbit(i))&#123;//不确定x的范围，所以直接使用最大值 tr[i]+=v; &#125;&#125;int query(int x)&#123; int res=0; for(int i=x;i;i-=lowbit(i))&#123; res+=tr[i]; &#125; return res;&#125;int main()&#123; cin&gt;&gt;n; int tt=n; memset(a,0,sizeof(a)); while(tt--)&#123; cin&gt;&gt;x&gt;&gt;y; x++; int num=query(x); add(x,1); a[num]++; &#125; for(int i=0;i&lt;n;i++)&#123; cout&lt;&lt;a[i]&lt;&lt;endl; &#125; return 0;&#125; 数列区间最大值题目链接：https://www.acwing.com/problem/content/description/1272/ Code： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;using namespace std;const int N = 1e5+5;int a[N];int n,m,x,y;struct node &#123; int l,r,maxx;&#125;tr[N*4];void build(int u,int l,int r)&#123; if(l==r) tr[u]=&#123;l,r,a[l]&#125;; else &#123; tr[u]=&#123;l,r&#125;; int mid = (l+r)&gt;&gt;1; build(u*2,l,mid);build(u*2+1,mid+1,r); tr[u].maxx=max(tr[u*2].maxx,tr[u*2+1].maxx); &#125;&#125;int query(int u,int l,int r)&#123; if(l&lt;=tr[u].l&amp;&amp;r&gt;=tr[u].r) return tr[u].maxx; else &#123; int maxx=-1e9; int mid = (tr[u].l+tr[u].r)&gt;&gt;1; if(l&lt;=mid) maxx=max(maxx,query(u*2,l,r)); if(r&gt;mid) maxx=max(maxx,query(u*2+1,l,r)); return maxx; &#125;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); build(1,1,n); while(m--)&#123; scanf("%d%d",&amp;x,&amp;y); printf("%d\n",query(1,x,y)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF 616 div2]]></title>
    <url>%2Fvoids3.github.io%2F2020%2F02%2F03%2FCF-616-div2%2F</url>
    <content type="text"><![CDATA[A.Even But Not Even题目链接：https://codeforces.com/contest/1291/problem/A题目大意：给你一个数字然后对数字进行删减后，使该数字不能被二整除但每一位上的和能被二整除解题思路：该数字不能被二整除，说明最后一位为奇数，和能被2整除，只要在其他位再找一位奇数即可(大佬的思路) 本蒟蒻的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int t,n;string s;typedef long long ll;int main()&#123; cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;n; cin&gt;&gt;s; ll len = s.length(); while((s[len-1]-'0')%2==0)&#123; len--; if(len&lt;=0) break; &#125;// cout&lt;&lt;len&lt;&lt;endl; if(len&lt;=0)&#123; cout&lt;&lt;-1&lt;&lt;endl; continue; &#125; s=s.substr(0,len); string tt=""; bool flag=0; ll sum=0; for(int i=0;i&lt;len-1;i++)&#123; sum+=s[i]-'0'; if((s[i]-'0')%2!=0&amp;&amp;flag==0) flag=1; else tt+=s[i]; &#125; tt+=s[len-1]; int len1=tt.length(); int num=0; for(int i=0;i&lt;len1;i++)&#123; num=i; if(tt[i]!='0')&#123; break; &#125; &#125; tt=tt.substr(num,len1-num); if(sum%2!=0)&#123; cout&lt;&lt;s&lt;&lt;endl; &#125; else &#123; if(flag) cout&lt;&lt;tt&lt;&lt;endl; else cout&lt;&lt;-1&lt;&lt;endl; &#125; &#125; return 0;&#125; 大佬的代码： 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int t,n;string s;typedef long long ll;int main()&#123; cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;n; cin&gt;&gt;s; ll len = s.length(); while((s[len-1]-'0')%2==0)&#123; len--; if(len&lt;=0) break; &#125; string tt=""; bool flag=0; for(int i=0;i&lt;len-1;i++)&#123; if((s[i]-'0')&amp;1) &#123; tt+=s[i]; flag=1; break; &#125; &#125; tt+=s[len-1]; if(flag)&#123; cout&lt;&lt;tt&lt;&lt;endl; &#125; else cout&lt;&lt;-1&lt;&lt;endl; &#125; return 0;&#125; B、Array Sharpening题目链接：https://codeforces.com/contest/1291/problem/B 题目大意：给你一个数组，问怎样的操作可以使数组变成单增或单减或先但增再单减，操作指可以使数组中的某一个正数多次减1 解题思路：变化后的数组满足以上条件，那么我们可以在变化后的数组找最长上升子序列和最长下降子序列，然后比较端点值 Code: 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;using namespace std;const int N = 3e5+5;int t,n,a[N];int main()&#123; cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i]; int i=0; for(i=0;i&lt;n;i++)&#123; //找最长上升子序列 if(a[i]&lt;i) break;//假设a[i]都是变化后的数组 &#125; bool flag=0; for(int j=n-1,k=0;j&gt;=0;j--,k++)&#123;//找最长下降子序列 if(a[j]&lt;k)&#123; if(j+1&gt;i-1)&#123; flag=1; &#125; break; &#125; &#125; if(flag) puts("No"); else puts("Yes"); &#125; return 0;&#125; C、Mind Control题目链接：https://codeforces.com/contest/1291/problem/C 题目大意：给你一个数组，对应n个人，每个人每次只能在头尾中取出一个数，你可以控制前k个人的取法，你在第m次取，问你能取到的最大值是多少 解题思路：双重循环，先遍历可控制的k次选择后所剩的数组，然后遍历不可控的m-k-1后所剩余的数组 Code： 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;using namespace std;int t,n,m,k;const int N = 5000;int a[N];int main()&#123; cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i]; k=min(m-1,k); int ans=-1; for(int i=0;i&lt;=k;i++)&#123;//枚举可控的k次选择后所剩区间 int minn=0x3f3f3f3f; for(int j=0;j&lt;m-k;j++)&#123;//再枚举不可控的m-k-1次选择后所剩的区间 int l=i+j,r=i+j+(n-m); minn=min(minn,max(a[l],a[r]));//在最坏的情况中选择 &#125; ans=max(ans,minn); &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树模板]]></title>
    <url>%2Fvoids3.github.io%2F2020%2F01%2F28%2F%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;iostream&gt;using namespace std;const int N = 1000;void build_tree(int arr[],int tree[],int node,int start,int end)&#123;//建树 if(start==end)&#123; tree[node]=arr[start]; &#125; else &#123; int left_node = node*2+1; int right_node = node*2+2; int mid = start+end&gt;&gt;1; build_tree(arr,tree,left_node,start,mid); build_tree(arr,tree,right_node,mid+1,end); tree[node]=tree[left_node]+tree[right_node]; &#125;&#125;void update_tree(int arr[],int tree[],int node,int start,int end,int idx,int val)&#123;//更新每个点的内容 if(start==end)&#123; arr[idx]=val; tree[node]=val; &#125; else &#123; int mid=start+end&gt;&gt;1; int left_node = node*2+1; int right_node = node*2+2; if(idx&gt;=start&amp;&amp;idx&lt;=mid)&#123; update_tree(arr,tree,left_node,start,mid,idx,val); &#125; else&#123; update_tree(arr,tree,right_node,mid+1,end,idx,val); &#125; tree[node]=tree[left_node]+tree[right_node]; &#125;&#125;int query_tree(int arr[],int tree[],int node,int start,int end,int L,int R)&#123;//求一段的距离和 if(L&gt;end||R&lt;start)&#123; return 0; &#125; else if(start&gt;=L&amp;&amp;end&lt;=R)&#123; return tree[node]; &#125; else if(start==end)&#123; return tree[node]; &#125; else &#123; int mid=start+end&gt;&gt;1; int left_node=node*2+1; int right_node=node*2+2; int sum_left=query_tree(arr,tree,left_node,start,mid,L,R); int sum_right=query_tree(arr,tree,right_node,mid+1,end,L,R); return sum_left+sum_right; &#125;&#125;int main()&#123; int arr[]=&#123;1,3,5,7,9,11&#125;; int size = 6; int tree[N]=&#123;0&#125;; build_tree(arr,tree,0,0,size-1); for(int i=0;i&lt;15;i++)&#123; printf("tree[%d]=%d\n",i,tree[i]); &#125; update_tree(arr,tree,0,0,size-1,4,6); printf("***********\n"); for(int i=0;i&lt;15;i++)&#123; printf("tree[%d]=%d\n",i,tree[i]); &#125; printf("***********\n"); int x=query_tree(arr,tree,0,0,size-1,2,5); cout&lt;&lt;x&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HPU训练3]]></title>
    <url>%2Fvoids3.github.io%2F2019%2F11%2F28%2FHPU%E8%AE%AD%E7%BB%833%2F</url>
    <content type="text"><![CDATA[A - Kefa and Park题目链接：http://codeforces.com/problemset/problem/580/C题目大意：kefa住在编号为1的房子里，现在kefa要去餐厅，餐厅位于树的叶子节点，现在给一个m，如果kefa去餐厅的路径连续遇到猫的个数大于m，该餐厅kefa就不会过去，1位置上有猫。问kefa可以去的餐厅个数。 解题思路：用dfs将图跑一遍即可，过程中标记连续遇到猫的个数，还有一个点就是需要判断该点是否为叶子节点。最好不要用链式前向星，该方法判断叶子节点不好判断。 Code: 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;const int N = 1e6+5;vector&lt;int&gt;ve[N];int n,m,st[N],ans;void dfs(int u,int k,int pr)&#123;//分别表示当前节点，连续猫的个数，父亲节点 if(k&gt;m) return ; int num=ve[u].size(); if(num==1&amp;&amp;u!=1)&#123; ans++; return ; &#125; for(int i=0;i&lt;num;i++)&#123; int v=ve[u][i]; if(v==pr) continue; if(st[v]) dfs(v,k+1,u); else dfs(v,0,u); &#125;&#125;int main()&#123; ans=0; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) cin&gt;&gt;st[i]; for(int i=1;i&lt;n;i++)&#123; int u,v; cin&gt;&gt;u&gt;&gt;v; ve[u].push_back(v); ve[v].push_back(u); &#125; dfs(1,st[1],0); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; B - Complete Tripartite题目链接：http://codeforces.com/problemset/problem/1228/D 题目大意：问能否将一个图分成三个集合，每个集合内部的点没有边，每个集合的点都和另外两个集合的点连有边，每个集合不能为空。 解题思路：先将1放在集合1，然后将和1相连的点全部置为2，剩下的点自然就是集合1里面的元素，然后再从集合2中随意找一个元素，遍历和它相连的点，如果该点不属于集合1，就将该点放在集合3中。这样就将三个集合找出来了。最后判断三个集合是否与题意有冲突即可。 Code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;vector&gt;using namespace std;const int N = 6e5+5,M=N*2;typedef long long ll;ll h[N],cnt;ll n,m,color[N],in[N];vector&lt;ll&gt;v[4];struct Edges&#123; ll to,nxt;&#125;eg[M];void add(ll u,ll v)&#123; eg[cnt].to=v; eg[cnt].nxt=h[u]; h[u]=cnt++;&#125;int main()&#123; memset(h,-1,sizeof(h)); cnt=0; cin&gt;&gt;n&gt;&gt;m; for(ll i=0;i&lt;m;i++)&#123; ll u,v; cin&gt;&gt;u&gt;&gt;v; in[u]++;in[v]++;//表示每个点和多少边相连 add(u,v);add(v,u); &#125; // cout&lt;&lt;"***********"&lt;&lt;endl; color[1]=1; for(ll i=h[1];i!=-1;i=eg[i].nxt)&#123;//先把和1相连的边的点都置为2 ll v=eg[i].to; color[v]=2; &#125; ll pos=-1; for(ll i=1;i&lt;=n;i++)&#123;//剩下的点的颜色都置为1 if(color[i]!=2) color[i]=1; else if(pos==-1)&#123; pos=i; &#125; &#125; if(pos==-1)&#123; cout&lt;&lt;-1&lt;&lt;endl; return 0; &#125; for(ll i=h[pos];i!=-1;i=eg[i].nxt)&#123;//和颜色为2的点相连的点颜色不为1就一定为3 ll v=eg[i].to; if(color[v]==1) continue; color[v]=3; &#125; ll len1,len2,len3; for(ll i=1;i&lt;=n;i++)&#123; if(color[i]==1) v[1].push_back(i); else if(color[i]==2) v[2].push_back(i); else v[3].push_back(i); &#125; bool flag=0; len1=v[1].size();len2=v[2].size();len3=v[3].size(); // cout&lt;&lt;"*************\n"; if(len1==0||len2==0||len3==0)&#123;//判断是否有集合为空 cout&lt;&lt;-1&lt;&lt;endl; return 0; &#125; for(ll i=0;i&lt;len1;i++)&#123; if(in[v[1][i]]!=len2+len3)&#123;//如果没有和集合2，3所有的点相连，就不符合条件 flag=1; break; &#125; for(int j=h[v[1][i]];j!=-1;j=eg[j].nxt)&#123;//如果集合内部存在边，不符合条件 int v=eg[j].to; if(color[v]==1) &#123; flag=1; break; &#125; &#125; &#125; // cout&lt;&lt;"*************\n"; // cout&lt;&lt;len2&lt;&lt;endl; // for(int i=1;i&lt;=n;i++)&#123; // cout&lt;&lt;h[i]&lt;&lt;endl; // &#125; for(ll i=0;i&lt;len2;i++)&#123; if(in[v[2][i]]!=len1+len3)&#123; flag=1; break; &#125; for(int j=h[v[2][i]];j!=-1;j=eg[j].nxt)&#123; int v=eg[j].to; if(color[v]==2) &#123; flag=1; break; &#125; // cout&lt;&lt;j&lt;&lt;endl; &#125; &#125; // cout&lt;&lt;"*************\n"; if(flag)&#123; cout&lt;&lt;-1&lt;&lt;endl; return 0; &#125; for(ll i=0;i&lt;len3;i++)&#123; if(in[v[3][i]]!=len1+len2)&#123; flag=1; break; &#125; for(int j=h[v[3][i]];j!=-1;j=eg[j].nxt)&#123; int v=eg[j].to; if(color[v]==3) &#123; flag=1; break; &#125; &#125; &#125; // cout&lt;&lt;"*************\n"; if(flag)&#123; cout&lt;&lt;-1&lt;&lt;endl; return 0; &#125; else &#123; for(ll i=1;i&lt;=n;i++)&#123; if(i==1) cout&lt;&lt;color[i]; else cout&lt;&lt;" "&lt;&lt;color[i]; &#125; cout&lt;&lt;endl; &#125; return 0;&#125; C - Shortest Cycle题目链接：http://codeforces.com/problemset/problem/1206/D 题目大意：两个数与运算不为0，那么就存在一条边，判断该图中是否存在有环，存在输出最小环的长度，反之输出-1 解题思路:根据抽屉原理，若n大于128，则最小环一定为3，反之跑floyd求最小环即可。 Code: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;using namespace std;const int N = 1e5+5;typedef long long ll;const ll inf = 1e14;ll a[N],dis[300][300],e[300][300];int n;ll floyd()&#123; ll res=inf; for(int k=1;k&lt;=n;k++)&#123; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; if(i==j||i==k||j==k) continue; res=min(res,dis[i][j]+e[j][k]+e[k][i]); &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]); &#125; &#125; &#125; return res==inf?-1:res;&#125;int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i]; if(a[i]==0)&#123; i--; n--; &#125; &#125; if(n&gt;128)&#123; cout&lt;&lt;3&lt;&lt;endl; &#125; else &#123; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; if(a[i]&amp;a[j] &amp;&amp; i!=j)&#123; dis[i][j]=e[i][j]=1; &#125; else &#123; dis[i][j]=e[i][j]=inf; &#125; &#125; &#125; cout&lt;&lt;floyd()&lt;&lt;endl; &#125; return 0;&#125; D - Alex and a Rhombus题目链接：http://codeforces.com/problemset/problem/1180/A 题目大意：思维题，根据图中规律，给出第n次操作图中小正方形的个数 解题思路：手动模拟可以得出，sn=n(n-1)2+1. Code: 1234567891011#include&lt;iostream&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; cout&lt;&lt;n*(n-1)*2+1&lt;&lt;endl; return 0;&#125; E - Nick and Array题目链接：http://codeforces.com/problemset/problem/1180/B 题目大意： 给你一个数组，每次操作形式为在数组中任意挑选几个数，每个数转换形式为ai=-ai-1;问怎样转换，使数组乘积最大。每个数都可多次操作。 解题思路：对于正数和0，转化为负数绝对值大于本身，明白这个后就简单了。如果数组元素个数为偶数，全部转化为负数即可。如果数组元素个数为奇数，将所有元素转化为负数后，将绝对值最大的再进行一次操作即可 Code: 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1e6+5;int a[N],b[N],c[N],n,num1,num2,num3;int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i]; &#125; int minn=0,temp; if(n%2==0)&#123; for(int i=1;i&lt;=n;i++)&#123; if(a[i]&gt;=0) a[i]=-a[i]-1; &#125; &#125; else if(n&amp;1)&#123; for(int i=1;i&lt;=n;i++)&#123; if(a[i]&gt;=0) a[i]=-a[i]-1; if(a[i]&lt;minn) &#123; minn=a[i]; temp=i; &#125; &#125; a[temp]=-a[temp]-1; &#125; for(int i=1;i&lt;=n;i++)&#123; if(i==1) cout&lt;&lt;a[i]; else cout&lt;&lt;" "&lt;&lt;a[i]; &#125; cout&lt;&lt;endl;return 0;&#125; F - Valeriy and Deque题目链接：http://codeforces.com/problemset/problem/1180/C 题目大意：每次操作将数组头两个数取出，然后将值大的放入数组头，值小的放在数组尾，问每次操作所取出来的两个数分别是多少。 解题思路：用到一种新函数，deque,双向队列，和队列操作差不多，多了从队头队尾取出加入元素的操作。找到数组中最大数后找循环节，对循环之前和进入循环后分别处理即可。另外这题也可以暴力写，毕竟有6s，每次都有这种大佬，暴力大法，无所不A。 Code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;const int N = 3e5+5;typedef long long ll;int n,m,maxx=0,num=0,ans[N];deque&lt;ll&gt;q;struct node &#123; int l,r;&#125;t[N];void solve()&#123; while(1)&#123; int x=q.front();q.pop_front(); int y=q.front();q.pop_front(); if(x==maxx)&#123; q.push_front(y); for(int i=1;i&lt;=n-1;i++)&#123; y=q.front();q.pop_front(); ans[i]=y; &#125; break; &#125; else &#123; num++; t[num].l=x;t[num].r=y; if(x&gt;y)&#123; q.push_front(x); q.push_back(y); &#125; else &#123; q.push_front(y); q.push_back(x); &#125; &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) &#123; int x; cin&gt;&gt;x; maxx=max(maxx,x); q.push_back(x); &#125; solve(); for(int i=0;i&lt;m;i++)&#123; ll c; cin&gt;&gt;c; if(c&lt;=num) cout&lt;&lt;t[c].l&lt;&lt;" "&lt;&lt;t[c].r&lt;&lt;endl; else &#123; c-=num; c%=(n-1); if(c==0) c=n-1;//如若刚好乘除，此时c为循环节最后一个元素 cout&lt;&lt;maxx&lt;&lt;" "&lt;&lt;ans[c]&lt;&lt;endl; &#125; &#125; return 0;&#125; G - Circle Metro题目链接：http://codeforces.com/problemset/problem/1169/A 题目大意：A,B坐两个列车坐到某个目标位置，列车循环转，问A,B在下车之前是否会出现在同一个站点 解题思路：sb题，枚举即可 Code: 12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;int n,a,x,b,y;int main()&#123; cin&gt;&gt;n&gt;&gt;a&gt;&gt;x&gt;&gt;b&gt;&gt;y; bool flag=0; if(a==b)&#123; flag=1; &#125; while(a!=x&amp;&amp;b!=y)&#123; a=a+1;b=b-1; if(a==n+1) a=1; if(b==0) b=n; if(a==b)&#123; flag=1; break; &#125; &#125; if(flag) cout&lt;&lt;"YES"&lt;&lt;endl; else cout&lt;&lt;"NO"&lt;&lt;endl; return 0;&#125; H - Pairs题目链接：http://codeforces.com/problemset/problem/1169/B 题目大意：找到两个数x,y；在给出的数组中至少有一个数和x或y相等。 解题思路：在第一行的两个数一个数为x，在剩下的里面找y。看是否满足条件。 Code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;map&gt;using namespace std;const int N = 3e5+5;typedef long long ll;ll n,m;struct node &#123; ll x,y;&#125;num[N];map&lt;ll,ll&gt;ma1,ma2;ll x1,x2,sum1,sum2,x,y;int main()&#123; sum1=1;sum2=1; cin&gt;&gt;n&gt;&gt;m; cin&gt;&gt;x1&gt;&gt;x2; for(ll i=2;i&lt;=m;i++) &#123; cin&gt;&gt;x&gt;&gt;y; if(x!=x1&amp;&amp;y!=x1)&#123; ma1[x]++; ma1[y]++; &#125; else sum1++; if(x!=x2&amp;&amp;y!=x2)&#123; ma2[x]++; ma2[y]++; &#125; else sum2++; &#125;// cout&lt;&lt;sum1&lt;&lt;endl bool flag=0; for(int i=1;i&lt;=n;i++)&#123; if(i!=x1)&#123; if(sum1+ma1[i]&gt;=m)&#123; cout&lt;&lt;"YES"&lt;&lt;endl; flag=1; break; &#125; &#125; if(i!=x2)&#123; if(sum2+ma2[i]&gt;=m)&#123; cout&lt;&lt;"YES"&lt;&lt;endl; flag=1;break; &#125; &#125; &#125;// cout&lt;&lt;"***********\n"; if(!flag) cout&lt;&lt;"NO"&lt;&lt;endl; return 0;&#125; I - Increasing by Modulo题目链接：http://codeforces.com/problemset/problem/1169/C 题目大意：将一个数组变为非递减序列问最少操作次数 解题思路：二分操作次数求最小，先将last值设为0，遍历一遍数组，如果a[i]大于last，看在当前操作次数下是否可以将a[i]转化为last,如果不能则更新last=a[i],如果a[i]小于last，看在当前操作次数下将a[i]变得大于等于last,不行则说明当前情况不成立。 Code: 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;using namespace std;const int N = 3e5+5;int n,m,a[N];bool check(int x)&#123; int now=0; for(int i=1;i&lt;=n;i++)&#123; if(now&lt;a[i])&#123; if(m-a[i]+now&gt;x) now=a[i]; &#125; else if(now&gt;a[i])&#123; if(a[i]+x&lt;now) return 0; &#125; &#125; return 1;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; int l=0,r=1e9,mid,ans=1e9; while(l&lt;r)&#123; mid = (l+r)&gt;&gt;1; if(check(mid))&#123; r=mid; ans=min(ans,mid); &#125; else l=mid+1; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>训练</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019CCPC江西省赛]]></title>
    <url>%2Fvoids3.github.io%2F2019%2F11%2F16%2F2019CCPC%E6%B1%9F%E8%A5%BF%E7%9C%81%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[A-Cotree题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=6567题目大意：有两棵树，在两个树间连一条边，求两两节点之间的距离和解题思路：两棵树分别称为a,b树，在a,b上分别找一点连接，其实就是找a,b树的重心。可以先分别求出a,b树内部点距离的和，再找到重心，然后再通过重心求a树上的点到b树上的点的距离和。 推荐题解：https://blog.csdn.net/lalala445566/article/details/97004819 Code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;typedef long long ll;const int N = 5e6+5;ll h[N],vis[N],cnt;ll sum[N],sum_num[N];//以该节点为根的树的所有节点到该节点距离的和，，以该节点为根的树的所有子节点 ll root_1,root_2,sum_root1,sum_root2;struct Edge&#123; ll to,nxt,w;&#125;eg[N*2]; void add(ll u,ll v)&#123;//链式前向星建图 eg[cnt].w=1;eg[cnt].to=v;eg[cnt].nxt=h[u];h[u]=cnt++;&#125;void dfs(ll x)&#123;//找到以每个节点为根节点的树的sum值和sum_num值 ll num=0; ll num_num=0; for(ll i=h[x];i!=-1;i=eg[i].nxt)&#123; ll v = eg[i].to; if(!vis[v])&#123; vis[v]=1; dfs(v); num+=sum_num[v]+sum[v]+1; num_num+=sum_num[v]+1; &#125; &#125; sum[x]=num; sum_num[x]=num_num;&#125;ll find_root(ll now,ll &amp;root,ll &amp;sum_root)&#123;//now为当前节点，root一直更新为当前最有可能是重心的节点，sum_root所有点到root距离的和 ll tot=0; tot+=sum[now];//将以所有节点为根的sum值累加 ll temp=sum[now];//记忆当前节点的sum值和sum_num值，以便恢复现场 ll temp_root=sum_num[now]; for(ll i=h[now];i!=-1;i=eg[i].nxt)&#123;//链式前向星遍历图 ll v=eg[i].to; if(!vis[v])&#123; vis[v]=1; //****更新数组，以v为重心是否比以root为重心距离更小 sum[now]-=(sum_num[v]+sum[v]+1); sum_num[now]-=(sum_num[v]+1); sum[v]+=(sum[now]+sum_num[now]+1); sum_num[v]+=(sum_num[now]+1); if(sum[v]&lt;sum_root)&#123;//如果满足条件，则更新重心及所有节点到重心的距离 sum_root=sum[v]; root=v; &#125; tot+=find_root(v,root,sum_root); sum[now]=temp;//恢复现场 sum_num[now]=temp_root; &#125; &#125; return tot;&#125;int main()&#123; memset(h,-1,sizeof(h)); memset(vis,0,sizeof(vis)); cnt=0; ll n,ans=0; scanf("%lld",&amp;n); ll u,v; for(int i=1;i&lt;=n-2;i++)&#123; scanf("%lld%lld",&amp;u,&amp;v); add(u,v);add(v,u); &#125; root_1=1; vis[1]=1; dfs(1);//先找一棵树上的sum值和sum_num值 // cout&lt;&lt;"*************\n"; sum_root1=sum[root_1]; for(int i=1;i&lt;=n;i++)&#123;//找另外一棵树 if(!vis[i])&#123; vis[i]=1; root_2=i; dfs(i); break; &#125; &#125;// cout&lt;&lt;"*************\n"; sum_root2=sum[root_2]; memset(vis,0,sizeof(vis));//将访问记录归零 vis[root_1]=1; ll temp=find_root(root_1,root_1,sum_root1);//temp所存的值是该棵树上以所有节点为根的sum值的总和 ，即该树上所有两点距离和的两倍，不明白可以模拟一下 ans+=temp/2;//内部距离和除以二，即为该树内部距离和 vis[root_2]=1; temp=find_root(root_2,root_2,sum_root2);//同理 ans+=temp/2; ans+=((sum[root_1]+sum_num[root_1]+1)*(sum_num[root_2]+1)+sum[root_2]*(sum_num[root_1]+1)); //前半部分是所有a树所有节点到b树重心的距离和乘以b树节点总个数 //后半部分是b树内部距离和乘以a树节点个数 cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; D.Wave题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=6570 题目大意：在字符串s中求奇数位置为i,偶数位置为j切i,j不相等的子序列最长为多少 解题思路：dp[i] [j] 存的是奇数位为i偶数为为j的最长长度。对于每个a[i]，更新dp[a[i]][j]为偶数时的情况，更新dp[j][a[i]]为奇数时的情况。因为以a[i],j为循环节长度是偶数才能在后面再加一个a[i],以j，a[i]为循环节长度是奇数才能在后面再加一个a[i]; 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int dp[200][200],s[100010];int main()&#123; int n,c; scanf("%d %d",&amp;n,&amp;c); memset(dp,0,sizeof dp); for(int i=0;i&lt;n;i++) &#123; scanf("%d",&amp;s[i]); for(int j=1;j&lt;=c;j++) &#123; if(j==s[i]) continue; if(dp[s[i]][j]%2==0) dp[s[i]][j]++; if(dp[j][s[i]]&amp;1) //当时用的else if 所以遍历样例到2时,dp[1][2]就连不上了 dp[j][s[i]]++; &#125; &#125; int ans=0; for(int i=1;i&lt;=c;i++) for(int j=1;j&lt;=c;j++) &#123; if(j==i) continue; ans=max(ans,dp[i][j]); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0; &#125; F - String题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=6572 题目大意：在字符串s中随机抽四个字母，求四个字母组合是avin的概率 解题思路：遍历s求字符串中a,v,i,n的个数,求出他们的乘积，再求出字符串长度的四次方，然后两者约分按格式输出即可 12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;algorithm&gt;using namespace std;map&lt;char,int&gt;ma;int main()&#123; int n; string s; cin&gt;&gt;n&gt;&gt;s; for(int i=0;i&lt;n;i++)&#123; ma[s[i]]++; &#125; int a=ma['a'],b=ma['v'],c=ma['i'],d=ma['n']; int ans,res; ans=a*b*c*d; res=n*n*n*n; int temp=__gcd(ans,res); if(ans==0) printf("%d/%d\n",ans,1); else printf("%d/%d\n",ans/temp,res/temp); return 0;&#125; G - Traffic题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=6573 题目大意：有从东到西行驶的车和从南到北行驶的车要使不发生车祸，求从南到北行驶的车最短停留时间 解题思路：如果要等，所有从南到北行驶的车都要等待相同的时间才能走，暴力枚举1到1000，符合条件break输出即可 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int n,m;int a[1050],b[1050],c[1050];bool check(int x)&#123; for(int i=0;i&lt;m;i++) c[i]=b[i]; for(int i=0;i&lt;m;i++) c[i]+=x; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;m;j++)&#123; if(a[i]==c[j]) return false; &#125; &#125; return true;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i]; for(int j=0;j&lt;m;j++) cin&gt;&gt;b[j]; sort(a,a+n); sort(b,b+m); int ans; for(int i=0;i&lt;=1000;i++)&#123; if(check(i))&#123; ans=i; break; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; H - Rng题目链接：u.edu.cn/showproblem.php?pid=6574 题目大意，在[1,c]中，找一个整数r,再从[1,r]中找一个整数l,变为一个新范围[l,r],这样重复两次问两次范围相交的概率 解题思路：打表找规律，发现规律为（n+1）/（2*n）,因为数比较大，需要用到逆元 123456789101112131415161718192021222324#include&lt;iostream&gt;using namespace std;typedef long long ll;const ll mod = 1e9+7;ll ksm(ll a,ll b)&#123; ll res=1; while(b)&#123; if(b&amp;1) res=(res*a)%mod; a=a*a%mod; b&gt;&gt;=1; &#125; return res;&#125;int main()&#123; ll n; cin&gt;&gt;n; cout&lt;&lt;(n+1)%mod*ksm(2*n,mod-2)%mod&lt;&lt;'\n'; return 0;&#125; I - Budget题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=6575 题目大意：将公司所有账目从三位小数保留成两位，问更新后差值是多少 解题思路：将差额求出来输出即可 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;int n;char p[20];int main()&#123; scanf("%d",&amp;n); double ans=0; while(n--)&#123; scanf("%s",p); int len=strlen(p); int temp=p[len-1]-'0'; if(temp&lt;=4) &#123; double t=temp*1.0/1000; ans-=t; &#125; else &#123; double t=temp*1.0/1000; ans+=(0.01-t); &#125; &#125; double pp;// ans=4.004; if(ans&lt;0) pp=-ans; else pp=ans; if(pp&gt;=0&amp;&amp;pp&lt;=1.0) printf("%.3lf\n",ans); else if(pp&gt;1.0)&#123; int num=(int)(pp*1000); int cnt=num%10; if(cnt&lt;=4) printf("%.2lf\n",ans); else&#123; if(ans&lt;0) printf("%.2lf\n",ans-0.01); else printf("%.2lf\n",ans+0.01); &#125; &#125; return 0;&#125; J - Worker题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=6576 题目大意：有n个工厂m个工人，每个工厂产出不同，问怎样分配工人使每个工厂产出相同 解题思路：找到工厂产出的最小公倍数，然后求出满足相同产出的最少工人数，然后求出总工人对最少工人数的倍数，然后求出每个工厂所需最少工人数乘以倍数即为每个工厂分配工人数，输出即可 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int N = 1005;ll a[N],b[N];ll n,m;int main()&#123; cin&gt;&gt;n&gt;&gt;m; ll ans=1; for(ll i=0;i&lt;n;i++)&#123; cin&gt;&gt;a[i]; ans=ans*a[i]/__gcd(ans,a[i]); &#125; ll sum=0; for(ll i=0;i&lt;n;i++)&#123; b[i]=ans/a[i]; sum+=b[i]; &#125; if(m%sum==0) &#123; puts("Yes"); ll t=m/sum; for(ll i=0;i&lt;n;i++)&#123; if(i) printf(" %lld",b[i]*t); else printf("%lld",b[i]*t); &#125; puts(""); &#125; else puts("No"); return 0;&#125; K - Class题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=6577 题目大意：x,y分别是a,b的和，差，求a*b 解题思路：求出a,b；相乘即可 1234567891011121314#include&lt;iostream&gt;using namespace std;int main()&#123; int x,y; cin&gt;&gt;x&gt;&gt;y; int a,b; a=(x+y)/2; b=x-a; cout&lt;&lt;a*b&lt;&lt;endl; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[最短路]]></title>
    <url>%2Fvoids3.github.io%2F2019%2F11%2F09%2F%E6%9C%80%E7%9F%AD%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[前五种都是单源求最短路，最后一种为多源求最短路一、朴素版dijkstra：稠密图，复杂度o(n^2);模板题：https://www.acwing.com/problem/content/851/Code：123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;cstring&gt; using namespace std;const int N = 105;int dist[N],st[N],g[N][N];int n,m;int dijkstra()&#123; memset(st,0,sizeof(st)); memset(dist,0x3f,sizeof(dist));//初始化距离 dist[1]=0; for(int i=0;i&lt;n;i++)&#123;//遍历n次 int t=-1;//不在st中，距离起点最近的点 for(int j=1;j&lt;=n;j++)&#123; if(!st[j]&amp;&amp;(t==-1||dist[t]&gt;dist[j]))&#123; t=j; &#125; &#125; st[t]=1; for(int j=1;j&lt;=n;j++)&#123; dist[j]=min(dist[j],dist[t]+g[t][j]); &#125; &#125; return dist[n]; &#125;int main()&#123; while(1)&#123; scanf("%d %d",&amp;n,&amp;m); if(n==0&amp;&amp;m==0) break; memset(g,0x3f,sizeof(g)); while(m--)&#123; int u,v,w; scanf("%d%d%d",&amp;u,&amp;v,&amp;w); g[u][v]=w; g[v][u]=w; &#125; int ans=dijkstra(); printf("%d\n",ans); &#125; return 0;&#125; 二、堆优化版的dijkstra 适用于稀疏图，复杂度：O(mlogn); 模板题：https://www.acwing.com/problem/content/852/ Code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;typedef pair&lt;int,int&gt;pii;const int N = 1e5+5;int h[N],dist[N],st[N],cnt;int n,m;struct node &#123; int to,nxt,w;&#125;eg[N];void add(int u,int v,int w)&#123; eg[cnt].to=v; eg[cnt].w=w; eg[cnt].nxt=h[u]; h[u]=cnt++;&#125;int dijkstra()&#123; memset(dist,0x3f,sizeof(dist)); memset(st,0,sizeof(st)); dist[1]=0; priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt;&gt;heap;//vector表示容器，greater表示小根堆 heap.push(&#123;0,1&#125;); while(heap.size())&#123; auto num=heap.top(); heap.pop(); int ver = num.second,dis=num.first; if(st[ver]) continue; st[ver]=1; for(int i=h[ver];i!=-1;i=eg[i].nxt)&#123; int v=eg[i].to; if(dist[v]&gt;dis+eg[i].w)&#123; dist[v]=dis+eg[i].w; heap.push(&#123;dist[v],v&#125;); &#125; &#125; &#125; if(dist[n]==0x3f3f3f3f) return -1; else return dist[n];&#125;int main()&#123; cnt=0; memset(h,-1,sizeof(h)); scanf("%d%d",&amp;n,&amp;m); while(m--)&#123; int u,v,w; scanf("%d%d%d",&amp;u,&amp;v,&amp;w); add(u,v,w); &#125; int ans=dijkstra(); printf("%d\n",ans); return 0;&#125; 三、spfa 处理带负权图，复杂度一般O(m)，最坏O(nm); 模板题：https://www.acwing.com/problem/content/853/ Code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;const int N = 1e5+5;int h[N],st[N],dist[N];int n,m,cnt;struct Edge&#123; int to,nxt,w;&#125;eg[N];void add(int u,int v,int w)&#123; eg[cnt].to=v;eg[cnt].nxt=h[u];eg[cnt].w=w;h[u]=cnt++; &#125;int spfa()&#123; memset(dist,0x3f,sizeof(dist)); dist[1]=0; queue&lt;int&gt;q; q.push(1); st[1]=true; while(q.size())&#123; int u=q.front(); q.pop(); st[u]=false; for(int i=h[u];i!=-1;i=eg[i].nxt)&#123; int v = eg[i].to; if(dist[v]&gt;dist[u]+eg[i].w)&#123; dist[v]=dist[u]+eg[i].w; q.push(v); st[v]=1; &#125; &#125; &#125; if(dist[n] &gt; 0x3f3f3f3f/2) return -1;//由于是带负权边的图，每次求出来的点会更新其他点，会导致dist[n]小于无穷大，但会大于无穷大的一半 else return dist[n];&#125;int main()&#123; cnt=0; memset(h,-1,sizeof(h)); scanf("%d%d",&amp;n,&amp;m); while(m--)&#123; int x,y,w; scanf("%d%d%d",&amp;x,&amp;y,&amp;w); add(x,y,w); &#125; int ans=spfa(); if(ans==-1)&#123; printf("impossible\n"); &#125; else &#123; printf("%d\n",ans); &#125; return 0;&#125; 四、spfa判断是否有负环 模板题：https://www.acwing.com/problem/content/854/ Code: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;const int N = 2010;int h[N],st[N],dist[N],num[N];int n,m,cnt;struct node &#123; int to,nxt,w;&#125;eg[N*5];//注意存的是边数void add(int u,int v,int w)&#123; eg[cnt].to=v; eg[cnt].w=w; eg[cnt].nxt=h[u]; h[u]=cnt++;&#125;bool spfa()&#123; memset(dist,0x3f,sizeof(dist)); memset(st,0,sizeof(st)); queue&lt;int&gt;q; for(int i=1;i&lt;=n;i++)&#123; q.push(i); st[i]=1; &#125; while(q.size())&#123; int u=q.front(); q.pop(); st[u]=0; for(int i=h[u];i!=-1;i=eg[i].nxt)&#123; int v = eg[i].to; if(dist[v]&gt;dist[u]+eg[i].w)&#123; num[v]=num[u]+1; if(num[v]&gt;=n) return 1;//如果num[v]大于等于n,说明至少有n+1个点，但总共只有n个点，便可得出存在负环 dist[v]=dist[u]+eg[i].w; q.push(v); st[v]=1; &#125; &#125; &#125; return 0;&#125;int main()&#123; memset(h,-1,sizeof(h)); cnt=0; scanf("%d%d",&amp;n,&amp;m); while(m--)&#123; int x,y,w; scanf("%d%d%d",&amp;x,&amp;y,&amp;w); add(x,y,w); &#125; if(spfa())&#123; puts("Yes"); &#125; else &#123; puts("No"); &#125; return 0;&#125; 五、bellman_ford 复杂度：O(nm) 适用于求有边数限制且带有负权边的最短路问题 模板题：https://www.acwing.com/problem/content/description/855/ 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 505,M=10010;int dist[N],backup[N];int n,m,k;struct Edge&#123; int u,v,w;&#125;eg[M];bool bellman_ford()&#123; memset(dist,0x3f,sizeof(dist)); dist[1]=0; for(int i=0;i&lt;k;i++)&#123;//循环k次 memcpy(backup,dist,sizeof(dist)); for(int j=0;j&lt;m;j++)&#123; int a=eg[j].u,b=eg[j].v,w=eg[j].w; // if(a==b) dist[b]=0; dist[b]=min(dist[b],backup[a]+w); &#125; &#125; if(dist[n] &gt; 0x3f3f3f3f/2) return 0; else return 1;&#125;int main()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); for(int i=0;i&lt;m;i++)&#123; int x,y,w; scanf("%d%d%d",&amp;x,&amp;y,&amp;w); eg[i]=&#123;x,y,w&#125;; &#125; if(bellman_ford()==0) puts("impossible"); else printf("%d\n",dist[n]); return 0;&#125; 六、floyd 复杂度：O(n^3) 模板题：https://www.acwing.com/problem/content/856/ Code: 123456789void floyd()&#123; for(int k=1;k&lt;=n;k++)&#123; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; g[i][j]=min(g[i][j],g[i][k]+g[k][j]); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HPU 上海选拔赛]]></title>
    <url>%2Fvoids3.github.io%2F2019%2F11%2F05%2FHPU-%E4%B8%8A%E6%B5%B7%E9%80%89%E6%8B%94%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[A - Berstagram题目链接：http://codeforces.com/problemset/problem/1250/A题目大意: 给你一个数从1到n的数组，然后依次给你m个数，到哪个数那个数会向前移动一位，问数组里的每个数到达最左边的位置与最右边的位置是多少解题思路：建立两个一维数组，一个保存每个数的当前位置，一个保存当前位置的数，然后再建立两个二维数组，一个保存每个数到达的最左边位置，一个保存到达的最右边位置 Code: 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;using namespace std;const int N = 1e5+5;int s[N],mp[N];int num[N][2];int main()&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++)&#123; s[i]=mp[i]=i;//s数组保存每个数的当前位置，mp数组保存每个位置的数 num[i][0]=num[i][1]=i;//0表示这个数到达的最左边位置，1表示这个数到达的最右边位置 &#125; int x,y; for(int i=1;i&lt;=m;i++)&#123; cin&gt;&gt;x;// cout&lt;&lt;s[x]&lt;&lt;endl; if(s[x]&gt;1)&#123; y=mp[s[x]-1]; num[x][0]=min(num[x][0],s[x]-1); num[y][1]=max(num[y][1],s[x]); int tmp=mp[s[x]];//更新每个位置的数 mp[s[x]]=mp[s[x]-1]; mp[s[x]-1]=tmp; s[x]--;//更新每个数的当前位置 s[y]++; &#125;// for(int i=1;i&lt;=n;i++)&#123;// cout&lt;&lt;mp[i];// &#125;// cout&lt;&lt;endl; &#125; for(int i=1;i&lt;=n;i++)&#123; cout&lt;&lt;num[i][0]&lt;&lt;" "&lt;&lt;num[i][1]&lt;&lt;"\n"; &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[回文子序列计数]]></title>
    <url>%2Fvoids3.github.io%2F2019%2F10%2F30%2F%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97%E8%AE%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目链接：https://ac.nowcoder.com/acm/problem/21587题目大意：给你一段字符串，统计每个字符作为回文中心的次数，然后按题意所给方式计算最后结果解题思路：难点在于怎样统计每个字符作为回文中心的次数。首先我们想到的是计算每个字符左右两边匹配字符的对数，从而求出结果。但这样遍历的话，应该会超时。 我们先假设某一个字符为中心字符，从右边往这个中心字符遍历，建立一个数组表示中心字符左右两边匹配字符的对数，每多出一对，就在该位置上增加多出来的种类数详见代码。 Code: 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;typedef long long ll;const int N = 3005;const ll mod = 1000000007;char s[N];ll x[N],y[N],dp[N];int main()&#123; memset(dp,0,sizeof(dp)); cin&gt;&gt;s+1; int len = strlen(s+1); s[0]='0'; for(int i=1;i&lt;=len;i++)&#123; x[i]=1; int cnt=0,sum=0; for(int j=len;j&gt;i;j--)&#123; cnt=dp[j]; //左右两边有n对相等的字符对应的删除种类数: //0 1 //1 1+1 //2 1+1+2 //3 1+1+2+3 if(s[i-1]==s[j])&#123; dp[j]=(dp[j]+sum+1)%mod;//dp[j]表示多出一对匹配的字符增加的种类数 &#125; sum=(sum+cnt)%mod;//sum则表示在该轮匹配中上一个字符dp[j]的个数 x[i]=(x[i]+dp[j])%mod;//每个字母是回文中心的个数 &#125; &#125; ll ans=x[1]*1; for(int i=2;i&lt;=len;i++)&#123; ans=ans^(x[i]*i)%mod;//异或的计算方法 &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Anna, Svyatoslav and Maps]]></title>
    <url>%2Fvoids3.github.io%2F2019%2F10%2F28%2FAnna-Svyatoslav-and-Maps%2F</url>
    <content type="text"><![CDATA[题目链接：https://codeforces.com/problemset/problem/1204/C 题目大意：给你一个长度为m的p串，找到p的一个字串按照该子序列进行最短路径移动时可以经过完整的p串。 Code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 105;const int NN = 1e6+5; const int inf = 0x3f3f3f3f;int d[N][N],n,m;int a[NN],p[NN];void floyd()&#123;//最短路 for(int k=1;k&lt;=n;k++)&#123; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; d[i][j]=min(d[i][j],d[i][k]+d[k][j]); &#125; &#125; &#125;&#125;int main()&#123; scanf("%d",&amp;n); getchar(); for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; char ch=getchar(); d[i][j]=(ch=='1'?1:inf); if(i==j) d[i][j]=0;//这点很重要 &#125; getchar(); &#125; cin&gt;&gt;m; for(int i=1;i&lt;=m;i++)&#123; cin&gt;&gt;p[i]; &#125; floyd(); int cnt=0,dis=0;//表示当前点到答案点的距离 a[++cnt]=p[1]; for(int i=2;i&lt;=m;i++)&#123; dis+=(d[p[i-1]][p[i]]);// cout&lt;&lt;dis&lt;&lt;" "&lt;&lt;d[a[cnt]][p[i]]&lt;&lt;endl; if(dis&gt;d[a[cnt]][p[i]])&#123;//如果距离大于记录点到该点的距离，则将上一个点记录 a[++cnt]=p[i-1]; dis=d[a[cnt]][p[i]];//更新距离 &#125; &#125; a[++cnt]=p[m];//将最后一个点加入记录 cout&lt;&lt;cnt&lt;&lt;"\n"; for(int i=1;i&lt;=cnt;i++)&#123; cout&lt;&lt;a[i]&lt;&lt;" "; &#125; cout&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #590 D. Distinct Characters Queries]]></title>
    <url>%2Fvoids3.github.io%2F2019%2F10%2F22%2FCodeforces-Round-590-D-Distinct-Characters-Queries%2F</url>
    <content type="text"><![CDATA[题目链接：https://codeforces.com/contest/1234/problem/D题目大意：给你一段字符串.操作1 ：将字符串x位置的字符改为字符z；操作2 : 在x,y范围内找到不同字符的个数。用到了线段树的知识，不知道的可以去b站看up主“正月点灯笼”的相关讲解。详见代码Code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;iostream&gt;using namespace std;const int N = 1e5+5;int tree[N*4],t,n,x,y;//线段树要开四倍数组大小 char z;string ss;void build_tree(int node,int start,int end)&#123; //建树 if(start==end)&#123; tree[node] = 1&lt;&lt;(ss[start]-'a');//将每个点的字母通过数然后用二进制表示 //如果ss[start]-'a'==0,左移一位后变为1 // 1 10 // 2-&gt;10 100 //以此类推，每个数都可以表示为一个所有位只有一个1的二进制数 //然后通过或运算得出来的数位上有几个1，就代表有几个不同的数，可以自己模拟一下 &#125; else &#123; int left_node=node*2+1; //通过模拟，可以知道该节点的左子节点的位置 int right_node=node*2+2;//同理 int mid = start+end&gt;&gt;1; build_tree(left_node,start,mid);//递归 build_tree(right_node,mid+1,end); tree[node]=tree[left_node] | tree[right_node]; //父节点的数等于左右子节点的或运算后的值 &#125;&#125;void update_tree(int node,int start,int end,int idx,int val)&#123;//对节点更新 if(start==end)&#123; tree[node]=val; &#125; else &#123; int left_node = 2*node+1; int right_node = 2*node+2; int mid = (start+end)&gt;&gt;1; if(idx&lt;=mid)&#123; update_tree(left_node,start,mid,idx,val); &#125; else&#123; update_tree(right_node,mid+1,end,idx,val); &#125; tree[node]=tree[left_node] | tree[right_node]; &#125;&#125; int query_tree(int node,int start,int end,int L,int R)&#123; if(L&gt;end||R&lt;start) return 0; else if(L&lt;=start&amp;&amp;R&gt;=end)&#123; return tree[node]; &#125; else &#123; int left_node=node*2+1; int right_node=node*2+2; int mid=start+end&gt;&gt;1; int res=0; res |= query_tree(left_node,start,mid,L,R); res |= query_tree(right_node,mid+1,end,L,R); return res; &#125;&#125;int main()&#123; cin&gt;&gt;ss; int len=ss.length(); build_tree(0,0,len-1);// for(int i=0;i&lt;13;i++)&#123;// cout&lt;&lt;tree[i]&lt;&lt;endl;// &#125; cin&gt;&gt;t; while(t--)&#123; int ans=0; cin&gt;&gt;n; if(n==1)&#123; cin&gt;&gt;x&gt;&gt;z; update_tree(0,0,len-1,x-1,1&lt;&lt;(z-'a')); //我是从0节点开始建树，所以更新的节点应减一 // for(int i=0;i&lt;13;i++)&#123;// cout&lt;&lt;tree[i]&lt;&lt;endl;// &#125; &#125; else &#123; cin&gt;&gt;x&gt;&gt;y; int res=query_tree(0,0,len-1,x-1,y-1);//同上 // cout&lt;&lt;"**********\n"; while(res)&#123; if(res&amp;1)&#123;//计算res表示的二进制数位上有几个1 ans++; &#125; res&gt;&gt;=1; &#125; cout&lt;&lt;ans&lt;&lt;"\n"; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[食物链]]></title>
    <url>%2Fvoids3.github.io%2F2019%2F10%2F15%2F%E9%A3%9F%E7%89%A9%E9%93%BE%2F</url>
    <content type="text"><![CDATA[原文链接：http://poj.org/problem?id=1182题解链接：https://www.luogu.org/problemnew/solution/P2024洛谷上Sooke写的题解很容易理解，刚开始看了好多题解没看懂，看到了两种题解，这个是容易理解且代码量少的。另外一种等我弄懂了再贴出来。 Code: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int N = 1e6+5;int pre[N];int find(int x)&#123;//寻找父节点 if(x==pre[x]) return x; else return pre[x]=find(pre[x]);&#125;int same(int x,int y)&#123; if(find(x)==find(y))&#123; return 1; &#125; else return 0;&#125;void join(int x,int y)&#123;//合并同类 int fx=find(x),fy=find(y); if(fx!=fy) pre[fx]=fy;&#125;int main()&#123; int n,k; scanf("%d%d",&amp;n,&amp;k); int d,x,y; for(int i=1;i&lt;=3*n;i++) pre[i]=i;//变为三个范围 int sum=0; for(int i=1;i&lt;=k;i++)&#123; scanf("%d%d%d",&amp;d,&amp;x,&amp;y); int fx=find(x),fy=find(y); if(x&gt;n||y&gt;n||x&lt;0||y&lt;0)&#123; sum++;continue; &#125; if(d==1)&#123; if(same(x,y+n)||same(x,y+2*n)) sum++; else &#123; join(x,y); join(x+n,y+n); join(x+2*n,y+2*n); &#125; &#125; else if(d==2)&#123; if(same(x,y)||same(x,y+2*n)) sum++; else &#123; join(x,y+n); join(x+n,y+2*n); join(x+2*n,y); &#125; &#125; &#125; printf("%d\n",sum); return 0;&#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[国庆训练4]]></title>
    <url>%2Fvoids3.github.io%2F2019%2F10%2F06%2F%E5%9B%BD%E5%BA%86%E8%AE%AD%E7%BB%834%2F</url>
    <content type="text"><![CDATA[F.Free Weights题目链接：https://codeforces.com/gym/101170/attachments题目大意：给你两排杠铃，每排的数量为n，即n对某一重量的杠铃，任意重量的杠铃可以不费力的推到相邻的空地方，问最少拿动多少的杠铃，可以使重量相等的杠铃排在一起。解题思路：刚开始以为上下相同也算排在一起，结果想了好久没有思路，后来看题解原来只有在一排排在一起才可以。我们可以先找到给定的杠铃中最重的一个，然后二分。其中还会使用到入栈出栈的操作。 Code： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;const int N = 1e6+5;ll a[N],b[N],n;bool check(ll k)&#123; stack&lt;int&gt;s; for(int i=1;i&lt;=n;i++)&#123; if(a[i]&gt;k)&#123; if(s.empty()) s.push(a[i]); else if(s.top()==a[i]) s.pop(); else return false; &#125; &#125; if(!s.empty()) return false; for(int i=1;i&lt;=n;i++)&#123; if(b[i]&gt;k)&#123; if(s.empty()) s.push(b[i]); else if(s.top()==b[i]) s.pop(); else return false; &#125; &#125; if(!s.empty()) return false; return true;&#125;int main()&#123; ll maxx=0; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i]; maxx=max(a[i],maxx); &#125; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;b[i]; maxx=max(b[i],maxx); &#125; ll l=0,r=maxx,ans=0; while(l&lt;=r)&#123;// 二分 ll mid=(l+r)&gt;&gt;1; if(check(mid))&#123; ans=mid; r=mid-1; &#125; else l=mid+1; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>国庆训练</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hpu 国庆训练2]]></title>
    <url>%2Fvoids3.github.io%2F2019%2F10%2F06%2FHpu-%E5%9B%BD%E5%BA%86%E8%AE%AD%E7%BB%832%2F</url>
    <content type="text"><![CDATA[A.Chat Group题目链接：http://codeforces.com/gym/101775/problem/A题目大意：给你n个人，在这n个人中找至少k个人建一个群，问最多可以建多少个群解题思路：所求为C(k,n) + C(k+1,n) +…+ C(n,n);由于n的范围是1e9,而k的范围是1e5,所以转化为2^k-C(1,n)-..-C(k-1,n);由于在求组合数中需要取模，用除法不好计算，所以用逆元来求。 Code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;using namespace std;typedef long long ll;const int maxn = 1e5+5;const ll mod = 1e9+7;ll inv[maxn];void init()&#123;//逆元打表 inv[1]=1; for(int i=2;i&lt;maxn;i++)&#123; inv[i]=(mod-(mod/i))*inv[mod%i]%mod; &#125;&#125;ll ksm(ll a,ll b)&#123; ll res=1; while(b)&#123; if(b&amp;1) res=res*a%mod; a=a*a%mod; b&gt;&gt;=1; &#125; return res;&#125;int main()&#123; ll t,n,k; cin&gt;&gt;t; init(); for(int mm=1;mm&lt;=t;mm++)&#123; cin&gt;&gt;n&gt;&gt;k; ll sum=ksm(2,n)-1; ll t=n,ans=0; for(int i=1;i&lt;k;)&#123; ans=(ans+t)%mod; t=(t*(n-i)%mod*inv[++i])%mod; &#125; ans=(sum-ans+mod)%mod; printf("Case #%d: %lld\n",mm,ans); &#125; return 0;&#125; B.Scapegoat 题目链接：http://codeforces.com/gym/101775/problem/B 题目大意：犯了n个错误，m个人承担，每个错误的严重程度不同，让求m个人承受严重程度的最小方差 解题思路：先让每个人承担一个错误，然后让剩下的m-n个人，去和其他人承受一个错误，但这需要判断和谁一起承担，所以需要用到优先队列。要使方差最小，需要用到贪心，只要使每个人承受的错误大小在平均数上下即可。详见代码。 Code: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;cstdio&gt;using namespace std;const int N = 2e5+5;double a[N];double s;struct node&#123; int id,n;//承担错误的编号，承担某一错误的人数 double cal,r;//承担错误的大小 node(int _id=0,int _n=0,double _cal=0)&#123;//初始化每个都要为0 id=_id,n=_n,cal=_cal; double res1=(cal-s)*(cal-s)*n; double res2=(a[id]/(n+1)-s)*(a[id]/(n+1)-s)*(n+1); r=res1-res2; &#125; friend bool operator &lt; (node a,node b)&#123; return a.r&lt;b.r; &#125;&#125;b[N];int main()&#123;// ios::sync_with_stdio(false);// cin.tie(0);cout.tie(0); int t,mm=1; scanf("%d",&amp;t); while(t--)&#123; int n,m; scanf("%d %d",&amp;n,&amp;m); priority_queue&lt;node&gt;q; s=0; for(int i=1;i&lt;=n;i++)&#123; scanf("%lf",&amp;a[i]); s+=a[i]; &#125; s/=m;//注意不是n，是m个人承担错误 for(int i=1;i&lt;=n;i++) q.push(node(i,1,a[i])); int temp=m-n; while(temp--)&#123; node p=q.top(); q.pop(); q.push(node(p.id,p.n+1,a[p.id]/(p.n+1))); &#125; int pp=1; while(!q.empty())&#123; b[pp++]=q.top(); q.pop(); &#125; double ans=0; for(int i=1;i&lt;pp;i++)&#123; ans+=(b[i].cal-s)*(b[i].cal-s)*b[i].n; &#125; ans/=m; printf("Case #%d: %.10lf\n",mm++,ans); &#125; return 0;&#125; L.SOS 题目链接：http://codeforces.com/gym/101775/problem/L 题目大意：给你一张1*N的棋盘，两个人下棋，谁先得到连续的SOS标志谁就胜利。Panda先生先手。 解题思路：1.S_ S是必胜局面，谁先营造出这样的局面且在这外面还有偶数个空位置。对于先手，当 N=7 时，先手先在4位置下一个S，则不管后手怎么下，先手都能创造出S _S的局面。然后观察7以后的奇数都可以创造出这样的局面，所以大于7的奇数都是先手赢。 2. 那什么时候后手能赢呢，想一想先手赢得条件，我们可以想到剩余7个连续空位置给后手操作时会营造对后手有利的局面，但考虑到先手要先放，所以可以想到–8 ，但什么时候不管怎样先手怎么下，都会给后手留下8个连续空格子呢，我们推一下就可以得到16，15的话是不满足的。由此可以得出当n&gt;=16,且为偶数时，后手赢。其余情况平局。 Code: 1234567891011121314151617#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int main()&#123; int t,n; scanf("%d",&amp;t); for(int i=1;i&lt;=t;i++)&#123; scanf("%d",&amp;n); if(n&gt;=7&amp;&amp;n%2==1) printf("Case #%d: Panda\n",i); else if(n&gt;=16&amp;&amp;n%2==0) printf("Case #%d: Sheep\n",i); else printf("Case #%d: Draw\n",i); &#125; return 0;&#125; J.Straight Master 题目链接：http://codeforces.com/gym/101775/problem/J 题目大意：给你一些牌，让你将这些牌按照3-5 张的顺序打出去，问这些牌能否都分成3-5 张的序列 解题思路：先介绍一下差分： 差分就是将数列中的每一项分别与前一项数做差，例如： 一个序列1 2 5 4 7 3，差分后得到1 1 3 -1 3 -4 -3 这里注意得到的差分序列第一个数和原来的第一个数一样（相当于第一个数减0） 差分序列最后比原序列多一个数（相当于0减最后一个数） 性质： 1、差分序列求前缀和可得原序列 2、将原序列区间[L,R]中的元素全部+1，可以转化操作为差分序列L处+1，R+1处-1 3、按照性质2得到，每次修改原序列一个区间+1，那么每次差分序列修改处增加的和减少的相同 由于要分成3-5 张的序列，只要保证每一段&gt;=3 即可，详见代码。 Code : 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;using namespace std;const int N = 2e5+5;int a[N],b[N];int main()&#123; int t; scanf("%d",&amp;t); for(int mm=1;mm&lt;=t;mm++)&#123; int n; scanf("%d",&amp;n); a[0]=0,b[0]=0; for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); b[i]=a[i]-a[i-1]; &#125; b[n+1]=-a[n]; if(b[2]&lt;0||b[3]&lt;0)&#123; printf("Case #%d: No\n",mm); continue; &#125; int sum=0; for(int i=1;i&lt;=n+1;i++)&#123;// cout&lt;&lt;b[i]&lt;&lt;endl; if(b[i]&gt;0) sum+=b[i]; int p=i+3; if(p&gt;n+1) break; if(b[p]&lt;0)&#123; sum+=b[p]; b[p]=0; &#125; if(sum&lt;0) break; &#125;// cout&lt;&lt;sum&lt;&lt;endl; if(sum==0) printf("Case #%d: Yes\n",mm); else printf("Case #%d: No\n",mm); &#125; return 0;&#125; K.Downgrade 题目链接：http://codeforces.com/gym/101775/problem/K 题目大意：一个sb在玩一个sb游戏，游戏有主等级和次等级，当次等级达到最大的时候，主等级才会升级，当这个sb一天不玩的话，主等级就会化为经验，次等级归为1，然后看这些经验所能达到的等级就是这个人现在的等级。 解题思路：当时写的时候读了好久，没看懂，后来一看题解秒懂，就是需要再注意当这个人的主等级变成和开始等级相同，就说明后来会是重复的，break就可以了。 Code: 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;typedef long long ll;const int N = 1e5+5;int l[N];int main()&#123; int t,a,b,n,mm=1; scanf("%d",&amp;t); while(t--)&#123; scanf("%d %d %d",&amp;a,&amp;b,&amp;n); for(int i=1;i&lt;=a;i++) scanf("%d",&amp;l[i]); int temp,pre;//经验值，最初等级 for(int i=1;i&lt;=n;i++)&#123; temp=a;b=1;pre=a;a=1; int q=1; while(--temp)&#123; ++b; if(b&gt;l[q])&#123; ++a; b=1; ++q; &#125; &#125; if(a==pre) break; &#125; printf("Case #%d: %d-%d\n",mm++,a,b); &#125; return 0;&#125;]]></content>
      <categories>
        <category>国庆训练</category>
      </categories>
      <tags>
        <tag>逆元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gathering Children]]></title>
    <url>%2Fvoids3.github.io%2F2019%2F09%2F28%2FGathering-Children%2F</url>
    <content type="text"><![CDATA[解题思路：最后数只会留在相邻的RL两个位置，对于每个L,用id数组记录左边离它最近的R位置，对于每个R，记录右边离它最近的L的位置;类似于以下情况：i: 1 2 3 4 5 6 7 8 9 10 11 12 —- R R L L L L R L R R L Lid[i]: 3 3 2 2 2 2 8 7 11 11 10 10 然后遍历整个字符串，t=abs(i-id[i]); L:t为奇数，最后到L位置，否则到R位置 R:t为奇数，最后到R位置，否则到L位置Code: 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;char ch[100005];int idx,id[100005],ans[100005];int main()&#123; scanf("%s",ch+1); int n=strlen(ch+1); for(int i=1;i&lt;=n;i++)&#123; if(ch[i]=='L') id[i]=idx; else idx=i; &#125; for(int i=n;i&gt;=1;i--)&#123; if(ch[i]=='R') id[i]=idx; else idx=i; &#125; for(int i=1;i&lt;=n;i++)&#123; if(ch[i]=='L')&#123; if((i-id[i])%2==1) ans[id[i]+1]++; else ans[id[i]]++; &#125; else &#123; if((id[i]-i)%2==1) ans[id[i]-1]++; else ans[id[i]]++; &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; cout&lt;&lt;ans[i]&lt;&lt;" "; &#125; return 0;&#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Alyona and Spreadsheet]]></title>
    <url>%2Fvoids3.github.io%2F2019%2F09%2F22%2FAlyona-and-Spreadsheet%2F</url>
    <content type="text"><![CDATA[解题思路： 用二维数组逐个查找会超时，用多个一维数组来表示： a[]存储每一行的值，b[]表示每一列最高能到达的行数,c[]表示每一行的数最高能到达的行数 ；具体看代码。Code: 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;using namespace std;const int N = 1e5+5;int a[N],b[N],c[N];//每一行的值，每一列能到达的最上行，每一行能到达的最上行 int main()&#123; int n,m,x; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=m;i++) b[i]=1;//初始化最上行为1 for(int i=1;i&lt;=n;i++)&#123; c[i]=i; for(int j=1;j&lt;=m;j++)&#123; cin&gt;&gt;x; if(x&lt;a[j]) b[j]=i;//更新每一列最高到达的行数 a[j]=x;//更新一行每列的值 if(c[i]&gt;b[j]) c[i]=b[j];//c表示最高能到达的行数，越小行数越高 &#125; &#125; int k,l,r; cin&gt;&gt;k; while(k--)&#123; cin&gt;&gt;l&gt;&gt;r; if(c[r]&lt;=l)&#123; printf("Yes\n"); &#125; else printf("No\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>cf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[删括号]]></title>
    <url>%2Fvoids3.github.io%2F2019%2F09%2F19%2F%E5%88%A0%E6%8B%AC%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[原题链接：https://ac.nowcoder.com/acm/problem/21303解题思路：用dp[i][j][k]数组，i表示s1前i个字符，j表示s2的前j个字符，k=s1删去的’(‘-s1删去的’)’; 如果s1前i个字符删去k个 ‘(‘ 与s2相符，则令dp[i][j][k]==true，最终只要满足dp[len1-1][len2-1][0]==true,即为Possible Code: 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 200;int dp[N][N][N]; int main()&#123; string ss,tt; cin&gt;&gt;ss&gt;&gt;tt; memset(dp,0,sizeof(dp)); int len1=ss.length(); int len2=tt.length(); dp[0][0][0]=1; for(int i=0;i&lt;len1;i++)&#123; for(int j=0;j&lt;len2;j++)&#123; for(int k=0;k&lt;len1/2;k++)&#123; if(dp[i][j][k])&#123; //当删除恰好为"()",且符合目标状态 if(k==0&amp;&amp;ss[i+1]==tt[j+1]) dp[i+1][j+1][k]=1; //下一字符为"(",差值k+1 if(ss[i+1]=='(') dp[i+1][j][k+1]=1; //凑够(),删去),差值k-1 else if(k) dp[i+1][j][k-1]=1; &#125; &#125; &#125; &#125; if(dp[len1-1][len2-1][0]) printf("Possible\n"); else printf("Impossible\n"); return 0;&#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HNOI2003]操作系统]]></title>
    <url>%2Fvoids3.github.io%2F2019%2F09%2F19%2FHNOI2003-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[题目链接：https://ac.nowcoder.com/acm/problem/20030解题思路：首先建立一个优先队列，队列中元素由优先级从大到小排列，如果优先级相同，则按开始时间从小到大排列 如果队列为空，则向其中添加进程，进程进行过程有以下两种情况 1.j进程可以在i进程开始之前结束，则将j进程从队列踢出并进行输出 2.j进程不能在i进程开始之前结束，则更新j进程的操作时间，然后重新入队 （如果i进程优先级小于等于j进程，由于i的开始时间小于j，故j进程仍比i进程先进行完，但还要比较j进程是否与其他进程的开始时间冲突） Code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;const int N = 1e6+5;struct node &#123; int id,st,ct,pr; friend bool operator &lt; (node a,node b)&#123;//优先队列 if(a.pr==b.pr) return a.st&gt;b.st;//如果优先级相同，返回开始时间小的 else return a.pr&lt;b.pr;//返回优先级大的 &#125;&#125;tt[N];priority_queue&lt;node&gt;q;int main()&#123; int cnt=0; while(~scanf("%d%d%d%d",&amp;tt[cnt].id,&amp;tt[cnt].st,&amp;tt[cnt].ct,&amp;tt[cnt].pr)) cnt++; int i=0; long long now; while(i&lt;cnt)&#123; if(q.empty()) q.push(tt[i]),now=tt[i].st,i++;//队列为空，则向其中添加元素 else &#123; node bb=q.top();q.pop(); if(now+bb.ct&lt;=tt[i].st)&#123;//队顶进程能在下一个进程开始前完成 now+=bb.ct; printf("%d %lld\n",bb.id,now);// q.push(tt[i]);now=tt[i].st;i++; //直接加入不行，但不知道原因 &#125; else &#123; bb.ct=bb.ct-tt[i].st+now;//如果不能完成，则更新队顶进程的操作时间，重新入队 now=tt[i].st; q.push(bb),q.push(tt[i]); i++; &#125; &#125; &#125; while(!q.empty())&#123;//将队列中剩余元素输出 node dd=q.top(); q.pop(); now+=dd.ct; printf("%d %lld\n",dd.id,now); &#125; return 0;&#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[被3整除的子序列]]></title>
    <url>%2Fvoids3.github.io%2F2019%2F09%2F18%2F%E8%A2%AB3%E6%95%B4%E9%99%A4%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[解题思路：1.首先要明白子序列的意思：如qwwweec，（qwe,wec等都是它的子序列）; 2.一个数如果可以被3整除，那么各位数之和也可以被3整除。 3.dp[i][j]表示前i位数子序列的余数为j的个数；（m表示余数，dp[i][j]应该等于dp[i-1][j]+dp[i-1][(j+3-m)%3]的和再模mod）； 令后半部分为dp[i-1][x],所以(x+m)%3=j+3,即x=(j+3-m)%3。 Code: 1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;typedef long long ll;const int mod = 1e9+7;int main()&#123; string ss; cin&gt;&gt;ss; int len = ss.length(); int dp[55][3]; memset(dp,0,sizeof(dp)); dp[0][(ss[0]-'0')%3]=1; for(int i=1;i&lt;len;i++)&#123; int m=(ss[i]-'0')%3;// dp[i][m]=(dp[i][m]+1)%mod; for(int j=0;j&lt;3;j++)&#123; dp[i][j]=(dp[i-1][j]+dp[i-1][(j+3-m)%3])%mod;//dp公式 &#125; dp[i][m]=(dp[i][m]+1)%mod;//初始化时为0，故计算时需加1 &#125; cout&lt;&lt;dp[len-1][0]%mod&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-154]]></title>
    <url>%2Fvoids3.github.io%2F2019%2F09%2F18%2Fleetcode-154%2F</url>
    <content type="text"><![CDATA[反转每对括号间的子串题目链接：https://leetcode-cn.com/problems/reverse-substrings-between-each-pair-of-parentheses/解题思路：未遇到右括号前就压栈，遇到右括号后就反转最近的左括号与右括号之间的元素，最后需要反转输出 反转括号间的元素可以用栈来操作，先出栈再入栈。 Code: 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: string reverseParentheses(string s) &#123; string ss; ss=s; stack&lt;char&gt;s1; int len = ss.length(); for(int i=0;i&lt;len;i++)&#123; if(ss[i]==')')&#123; string ch=""; while(s1.top()!='(')&#123; ch+=s1.top(); s1.pop(); &#125; s1.pop(); for(int j=0;j&lt;ch.length();j++)&#123; s1.push(ch[j]); &#125; &#125; else &#123; s1.push(ss[i]); &#125; &#125; string tt=""; while(!s1.empty())&#123; tt+=s1.top(); s1.pop(); &#125; reverse(tt.begin(),tt.end()); return tt; &#125;&#125;; K次串联后最大子数组之和 题目链接：https://leetcode-cn.com/problems/k-concatenation-maximum-sum/ 解题思路：lmax表示单个数组的最大前缀和，rmax表示单个数组的最大后缀和，maxx表示单个数组最大连续和,sum表示单个数组总和 1.如果n==1;返回maxx即可 2.如果n&gt;1;如果sum&gt;=0;比较maxx与sum*(k-2)+lmax+rmax. 如果sum&lt;0;比较maxx与lmax+rmax. Code: 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: int kConcatenationMaxSum(vector&lt;int&gt;&amp; arr, int k) &#123; typedef long long ll; long long mod=1e9+7; ll lmax=0,rmax=0; ll cur=0; int n=arr.size(); for(int i=0;i&lt;n;i++)&#123; cur+=arr[i]; lmax=max(lmax,cur); &#125; cur=0; for(int i=n-1;i&gt;=0;i--)&#123; cur+=arr[i]; rmax=max(rmax,cur); &#125; //最大连续和 ll maxx=0,sum=0; cur=0; for(int i=0;i&lt;n;i++)&#123; sum+=arr[i]; cur+=arr[i]; if(cur&lt;0) cur=0; maxx=max(maxx,cur); &#125; if(k==1) return maxx%mod; else&#123; //sum&gt;=0 maxx=max(maxx,lmax+rmax+(k-2)*sum); //sum&lt;0 maxx=max(maxx,lmax+rmax); return maxx%mod; &#125; &#125;&#125;;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Minimum Sum LCM]]></title>
    <url>%2Fvoids3.github.io%2F2019%2F09%2F14%2FMinimum-Sum-LCM%2F</url>
    <content type="text"><![CDATA[解题思路： 首先需要知道分解质因数的知识，其次需要注意到两个点。 1.如果n为质数或为1，因为求lcm最少需要两个数，所以结果应为n+1. 2.如果一个数有多个相同的质因子，应将他们相乘后再相加，如4，8；他们的结果应为质因子相乘后再加1. Code： 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;map&gt;using namespace std;typedef long long ll; int main()&#123; ll n,k=1; while(~scanf("%lld",&amp;n)&amp;&amp;n)&#123; ll ans=0; vector&lt;ll&gt;ve; map&lt;ll,ll&gt;ma; for(ll i=2;i*i&lt;=n;i++)&#123; if(n%i==0)&#123; ve.push_back(i); &#125; while(n%i==0)&#123; ma[i]++; n/=i; &#125; &#125; if(!ve.size())&#123;//ve.size()==0,说明n为质数 ans=n+1; &#125; else &#123; if(ve.size()==1 || n!=1)//如果ve.size()==1,说明只有一个相同的质因子，此时n==1,应加上n ans += n;//如果n!=1且ve.size()&gt;1,此时n&gt;1，根据唯一分解定理，应加上n for(ll i=0;i&lt;ve.size();i++)&#123; ans += pow(ve[i],ma[ve[i]]); &#125; &#125; printf("Case %lld: %lld\n",k++,ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>唯一分解定理</tag>
      </tags>
  </entry>
</search>
