<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Anna, Svyatoslav and Maps]]></title>
    <url>%2Fvoids3.github.io%2F2019%2F10%2F28%2FAnna-Svyatoslav-and-Maps%2F</url>
    <content type="text"><![CDATA[题目链接：https://codeforces.com/problemset/problem/1204/C 题目大意：给你一个长度为m的p串，找到p的一个字串按照该子序列进行最短路径移动时可以经过完整的p串。 Code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 105;const int NN = 1e6+5; const int inf = 0x3f3f3f3f;int d[N][N],n,m;int a[NN],p[NN];void floyd()&#123;//最短路 for(int k=1;k&lt;=n;k++)&#123; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; d[i][j]=min(d[i][j],d[i][k]+d[k][j]); &#125; &#125; &#125;&#125;int main()&#123; scanf("%d",&amp;n); getchar(); for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; char ch=getchar(); d[i][j]=(ch=='1'?1:inf); if(i==j) d[i][j]=0;//这点很重要 &#125; getchar(); &#125; cin&gt;&gt;m; for(int i=1;i&lt;=m;i++)&#123; cin&gt;&gt;p[i]; &#125; floyd(); int cnt=0,dis=0;//表示当前点到答案点的距离 a[++cnt]=p[1]; for(int i=2;i&lt;=m;i++)&#123; dis+=(d[p[i-1]][p[i]]);// cout&lt;&lt;dis&lt;&lt;" "&lt;&lt;d[a[cnt]][p[i]]&lt;&lt;endl; if(dis&gt;d[a[cnt]][p[i]])&#123;//如果距离大于记录点到该点的距离，则将上一个点记录 a[++cnt]=p[i-1]; dis=d[a[cnt]][p[i]];//更新距离 &#125; &#125; a[++cnt]=p[m];//将最后一个点加入记录 cout&lt;&lt;cnt&lt;&lt;"\n"; for(int i=1;i&lt;=cnt;i++)&#123; cout&lt;&lt;a[i]&lt;&lt;" "; &#125; cout&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #590 D. Distinct Characters Queries]]></title>
    <url>%2Fvoids3.github.io%2F2019%2F10%2F22%2FCodeforces-Round-590-D-Distinct-Characters-Queries%2F</url>
    <content type="text"><![CDATA[题目链接：https://codeforces.com/contest/1234/problem/D题目大意：给你一段字符串.操作1 ：将字符串x位置的字符改为字符z；操作2 : 在x,y范围内找到不同字符的个数。用到了线段树的知识，不知道的可以去b站看up主“正月点灯笼”的相关讲解。详见代码Code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;iostream&gt;using namespace std;const int N = 1e5+5;int tree[N*4],t,n,x,y;//线段树要开四倍数组大小 char z;string ss;void build_tree(int node,int start,int end)&#123; //建树 if(start==end)&#123; tree[node] = 1&lt;&lt;(ss[start]-'a');//将每个点的字母通过数然后用二进制表示 //如果ss[start]-'a'==0,左移一位后变为1 // 1 10 // 2-&gt;10 100 //以此类推，每个数都可以表示为一个所有位只有一个1的二进制数 //然后通过或运算得出来的数位上有几个1，就代表有几个不同的数，可以自己模拟一下 &#125; else &#123; int left_node=node*2+1; //通过模拟，可以知道该节点的左子节点的位置 int right_node=node*2+2;//同理 int mid = start+end&gt;&gt;1; build_tree(left_node,start,mid);//递归 build_tree(right_node,mid+1,end); tree[node]=tree[left_node] | tree[right_node]; //父节点的数等于左右子节点的或运算后的值 &#125;&#125;void update_tree(int node,int start,int end,int idx,int val)&#123;//对节点更新 if(start==end)&#123; tree[node]=val; &#125; else &#123; int left_node = 2*node+1; int right_node = 2*node+2; int mid = (start+end)&gt;&gt;1; if(idx&lt;=mid)&#123; update_tree(left_node,start,mid,idx,val); &#125; else&#123; update_tree(right_node,mid+1,end,idx,val); &#125; tree[node]=tree[left_node] | tree[right_node]; &#125;&#125; int query_tree(int node,int start,int end,int L,int R)&#123; if(L&gt;end||R&lt;start) return 0; else if(L&lt;=start&amp;&amp;R&gt;=end)&#123; return tree[node]; &#125; else &#123; int left_node=node*2+1; int right_node=node*2+2; int mid=start+end&gt;&gt;1; int res=0; res |= query_tree(left_node,start,mid,L,R); res |= query_tree(right_node,mid+1,end,L,R); return res; &#125;&#125;int main()&#123; cin&gt;&gt;ss; int len=ss.length(); build_tree(0,0,len-1);// for(int i=0;i&lt;13;i++)&#123;// cout&lt;&lt;tree[i]&lt;&lt;endl;// &#125; cin&gt;&gt;t; while(t--)&#123; int ans=0; cin&gt;&gt;n; if(n==1)&#123; cin&gt;&gt;x&gt;&gt;z; update_tree(0,0,len-1,x-1,1&lt;&lt;(z-'a')); //我是从0节点开始建树，所以更新的节点应减一 // for(int i=0;i&lt;13;i++)&#123;// cout&lt;&lt;tree[i]&lt;&lt;endl;// &#125; &#125; else &#123; cin&gt;&gt;x&gt;&gt;y; int res=query_tree(0,0,len-1,x-1,y-1);//同上 // cout&lt;&lt;"**********\n"; while(res)&#123; if(res&amp;1)&#123;//计算res表示的二进制数位上有几个1 ans++; &#125; res&gt;&gt;=1; &#125; cout&lt;&lt;ans&lt;&lt;"\n"; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[食物链]]></title>
    <url>%2Fvoids3.github.io%2F2019%2F10%2F15%2F%E9%A3%9F%E7%89%A9%E9%93%BE%2F</url>
    <content type="text"><![CDATA[原文链接：http://poj.org/problem?id=1182题解链接：https://www.luogu.org/problemnew/solution/P2024洛谷上Sooke写的题解很容易理解，刚开始看了好多题解没看懂，看到了两种题解，这个是容易理解且代码量少的。另外一种等我弄懂了再贴出来。 Code: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int N = 1e6+5;int pre[N];int find(int x)&#123;//寻找父节点 if(x==pre[x]) return x; else return pre[x]=find(pre[x]);&#125;int same(int x,int y)&#123; if(find(x)==find(y))&#123; return 1; &#125; else return 0;&#125;void join(int x,int y)&#123;//合并同类 int fx=find(x),fy=find(y); if(fx!=fy) pre[fx]=fy;&#125;int main()&#123; int n,k; scanf("%d%d",&amp;n,&amp;k); int d,x,y; for(int i=1;i&lt;=3*n;i++) pre[i]=i;//变为三个范围 int sum=0; for(int i=1;i&lt;=k;i++)&#123; scanf("%d%d%d",&amp;d,&amp;x,&amp;y); int fx=find(x),fy=find(y); if(x&gt;n||y&gt;n||x&lt;0||y&lt;0)&#123; sum++;continue; &#125; if(d==1)&#123; if(same(x,y+n)||same(x,y+2*n)) sum++; else &#123; join(x,y); join(x+n,y+n); join(x+2*n,y+2*n); &#125; &#125; else if(d==2)&#123; if(same(x,y)||same(x,y+2*n)) sum++; else &#123; join(x,y+n); join(x+n,y+2*n); join(x+2*n,y); &#125; &#125; &#125; printf("%d\n",sum); return 0;&#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[国庆训练4]]></title>
    <url>%2Fvoids3.github.io%2F2019%2F10%2F06%2F%E5%9B%BD%E5%BA%86%E8%AE%AD%E7%BB%834%2F</url>
    <content type="text"><![CDATA[F.Free Weights题目链接：https://codeforces.com/gym/101170/attachments题目大意：给你两排杠铃，每排的数量为n，即n对某一重量的杠铃，任意重量的杠铃可以不费力的推到相邻的空地方，问最少拿动多少的杠铃，可以使重量相等的杠铃排在一起。解题思路：刚开始以为上下相同也算排在一起，结果想了好久没有思路，后来看题解原来只有在一排排在一起才可以。我们可以先找到给定的杠铃中最重的一个，然后二分。其中还会使用到入栈出栈的操作。 Code： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;const int N = 1e6+5;ll a[N],b[N],n;bool check(ll k)&#123; stack&lt;int&gt;s; for(int i=1;i&lt;=n;i++)&#123; if(a[i]&gt;k)&#123; if(s.empty()) s.push(a[i]); else if(s.top()==a[i]) s.pop(); else return false; &#125; &#125; if(!s.empty()) return false; for(int i=1;i&lt;=n;i++)&#123; if(b[i]&gt;k)&#123; if(s.empty()) s.push(b[i]); else if(s.top()==b[i]) s.pop(); else return false; &#125; &#125; if(!s.empty()) return false; return true;&#125;int main()&#123; ll maxx=0; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i]; maxx=max(a[i],maxx); &#125; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;b[i]; maxx=max(b[i],maxx); &#125; ll l=0,r=maxx,ans=0; while(l&lt;=r)&#123;// 二分 ll mid=(l+r)&gt;&gt;1; if(check(mid))&#123; ans=mid; r=mid-1; &#125; else l=mid+1; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>国庆训练</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hpu 国庆训练2]]></title>
    <url>%2Fvoids3.github.io%2F2019%2F10%2F06%2FHpu-%E5%9B%BD%E5%BA%86%E8%AE%AD%E7%BB%832%2F</url>
    <content type="text"><![CDATA[A.Chat Group题目链接：http://codeforces.com/gym/101775/problem/A题目大意：给你n个人，在这n个人中找至少k个人建一个群，问最多可以建多少个群解题思路：所求为C(k,n) + C(k+1,n) +…+ C(n,n);由于n的范围是1e9,而k的范围是1e5,所以转化为2^k-C(1,n)-..-C(k-1,n);由于在求组合数中需要取模，用除法不好计算，所以用逆元来求。 Code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;using namespace std;typedef long long ll;const int maxn = 1e5+5;const ll mod = 1e9+7;ll inv[maxn];void init()&#123;//逆元打表 inv[1]=1; for(int i=2;i&lt;maxn;i++)&#123; inv[i]=(mod-(mod/i))*inv[mod%i]%mod; &#125;&#125;ll ksm(ll a,ll b)&#123; ll res=1; while(b)&#123; if(b&amp;1) res=res*a%mod; a=a*a%mod; b&gt;&gt;=1; &#125; return res;&#125;int main()&#123; ll t,n,k; cin&gt;&gt;t; init(); for(int mm=1;mm&lt;=t;mm++)&#123; cin&gt;&gt;n&gt;&gt;k; ll sum=ksm(2,n)-1; ll t=n,ans=0; for(int i=1;i&lt;k;)&#123; ans=(ans+t)%mod; t=(t*(n-i)%mod*inv[++i])%mod; &#125; ans=(sum-ans+mod)%mod; printf("Case #%d: %lld\n",mm,ans); &#125; return 0;&#125; B.Scapegoat 题目链接：http://codeforces.com/gym/101775/problem/B 题目大意：犯了n个错误，m个人承担，每个错误的严重程度不同，让求m个人承受严重程度的最小方差 解题思路：先让每个人承担一个错误，然后让剩下的m-n个人，去和其他人承受一个错误，但这需要判断和谁一起承担，所以需要用到优先队列。要使方差最小，需要用到贪心，只要使每个人承受的错误大小在平均数上下即可。详见代码。 Code: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;cstdio&gt;using namespace std;const int N = 2e5+5;double a[N];double s;struct node&#123; int id,n;//承担错误的编号，承担某一错误的人数 double cal,r;//承担错误的大小 node(int _id=0,int _n=0,double _cal=0)&#123;//初始化每个都要为0 id=_id,n=_n,cal=_cal; double res1=(cal-s)*(cal-s)*n; double res2=(a[id]/(n+1)-s)*(a[id]/(n+1)-s)*(n+1); r=res1-res2; &#125; friend bool operator &lt; (node a,node b)&#123; return a.r&lt;b.r; &#125;&#125;b[N];int main()&#123;// ios::sync_with_stdio(false);// cin.tie(0);cout.tie(0); int t,mm=1; scanf("%d",&amp;t); while(t--)&#123; int n,m; scanf("%d %d",&amp;n,&amp;m); priority_queue&lt;node&gt;q; s=0; for(int i=1;i&lt;=n;i++)&#123; scanf("%lf",&amp;a[i]); s+=a[i]; &#125; s/=m;//注意不是n，是m个人承担错误 for(int i=1;i&lt;=n;i++) q.push(node(i,1,a[i])); int temp=m-n; while(temp--)&#123; node p=q.top(); q.pop(); q.push(node(p.id,p.n+1,a[p.id]/(p.n+1))); &#125; int pp=1; while(!q.empty())&#123; b[pp++]=q.top(); q.pop(); &#125; double ans=0; for(int i=1;i&lt;pp;i++)&#123; ans+=(b[i].cal-s)*(b[i].cal-s)*b[i].n; &#125; ans/=m; printf("Case #%d: %.10lf\n",mm++,ans); &#125; return 0;&#125; L.SOS 题目链接：http://codeforces.com/gym/101775/problem/L 题目大意：给你一张1*N的棋盘，两个人下棋，谁先得到连续的SOS标志谁就胜利。Panda先生先手。 解题思路：1.S_ S是必胜局面，谁先营造出这样的局面且在这外面还有偶数个空位置。对于先手，当 N=7 时，先手先在4位置下一个S，则不管后手怎么下，先手都能创造出S _S的局面。然后观察7以后的奇数都可以创造出这样的局面，所以大于7的奇数都是先手赢。 2. 那什么时候后手能赢呢，想一想先手赢得条件，我们可以想到剩余7个连续空位置给后手操作时会营造对后手有利的局面，但考虑到先手要先放，所以可以想到–8 ，但什么时候不管怎样先手怎么下，都会给后手留下8个连续空格子呢，我们推一下就可以得到16，15的话是不满足的。由此可以得出当n&gt;=16,且为偶数时，后手赢。其余情况平局。 Code: 1234567891011121314151617#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int main()&#123; int t,n; scanf("%d",&amp;t); for(int i=1;i&lt;=t;i++)&#123; scanf("%d",&amp;n); if(n&gt;=7&amp;&amp;n%2==1) printf("Case #%d: Panda\n",i); else if(n&gt;=16&amp;&amp;n%2==0) printf("Case #%d: Sheep\n",i); else printf("Case #%d: Draw\n",i); &#125; return 0;&#125; J.Straight Master 题目链接：http://codeforces.com/gym/101775/problem/J 题目大意：给你一些牌，让你将这些牌按照3-5 张的顺序打出去，问这些牌能否都分成3-5 张的序列 解题思路：先介绍一下差分： 差分就是将数列中的每一项分别与前一项数做差，例如： 一个序列1 2 5 4 7 3，差分后得到1 1 3 -1 3 -4 -3 这里注意得到的差分序列第一个数和原来的第一个数一样（相当于第一个数减0） 差分序列最后比原序列多一个数（相当于0减最后一个数） 性质： 1、差分序列求前缀和可得原序列 2、将原序列区间[L,R]中的元素全部+1，可以转化操作为差分序列L处+1，R+1处-1 3、按照性质2得到，每次修改原序列一个区间+1，那么每次差分序列修改处增加的和减少的相同 由于要分成3-5 张的序列，只要保证每一段&gt;=3 即可，详见代码。 Code : 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;using namespace std;const int N = 2e5+5;int a[N],b[N];int main()&#123; int t; scanf("%d",&amp;t); for(int mm=1;mm&lt;=t;mm++)&#123; int n; scanf("%d",&amp;n); a[0]=0,b[0]=0; for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); b[i]=a[i]-a[i-1]; &#125; b[n+1]=-a[n]; if(b[2]&lt;0||b[3]&lt;0)&#123; printf("Case #%d: No\n",mm); continue; &#125; int sum=0; for(int i=1;i&lt;=n+1;i++)&#123;// cout&lt;&lt;b[i]&lt;&lt;endl; if(b[i]&gt;0) sum+=b[i]; int p=i+3; if(p&gt;n+1) break; if(b[p]&lt;0)&#123; sum+=b[p]; b[p]=0; &#125; if(sum&lt;0) break; &#125;// cout&lt;&lt;sum&lt;&lt;endl; if(sum==0) printf("Case #%d: Yes\n",mm); else printf("Case #%d: No\n",mm); &#125; return 0;&#125; K.Downgrade 题目链接：http://codeforces.com/gym/101775/problem/K 题目大意：一个sb在玩一个sb游戏，游戏有主等级和次等级，当次等级达到最大的时候，主等级才会升级，当这个sb一天不玩的话，主等级就会化为经验，次等级归为1，然后看这些经验所能达到的等级就是这个人现在的等级。 解题思路：当时写的时候读了好久，没看懂，后来一看题解秒懂，就是需要再注意当这个人的主等级变成和开始等级相同，就说明后来会是重复的，break就可以了。 Code: 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;typedef long long ll;const int N = 1e5+5;int l[N];int main()&#123; int t,a,b,n,mm=1; scanf("%d",&amp;t); while(t--)&#123; scanf("%d %d %d",&amp;a,&amp;b,&amp;n); for(int i=1;i&lt;=a;i++) scanf("%d",&amp;l[i]); int temp,pre;//经验值，最初等级 for(int i=1;i&lt;=n;i++)&#123; temp=a;b=1;pre=a;a=1; int q=1; while(--temp)&#123; ++b; if(b&gt;l[q])&#123; ++a; b=1; ++q; &#125; &#125; if(a==pre) break; &#125; printf("Case #%d: %d-%d\n",mm++,a,b); &#125; return 0;&#125;]]></content>
      <categories>
        <category>国庆训练</category>
      </categories>
      <tags>
        <tag>逆元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gathering Children]]></title>
    <url>%2Fvoids3.github.io%2F2019%2F09%2F28%2FGathering-Children%2F</url>
    <content type="text"><![CDATA[解题思路：最后数只会留在相邻的RL两个位置，对于每个L,用id数组记录左边离它最近的R位置，对于每个R，记录右边离它最近的L的位置;类似于以下情况：i: 1 2 3 4 5 6 7 8 9 10 11 12 —- R R L L L L R L R R L Lid[i]: 3 3 2 2 2 2 8 7 11 11 10 10 然后遍历整个字符串，t=abs(i-id[i]); L:t为奇数，最后到L位置，否则到R位置 R:t为奇数，最后到R位置，否则到L位置Code: 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;char ch[100005];int idx,id[100005],ans[100005];int main()&#123; scanf("%s",ch+1); int n=strlen(ch+1); for(int i=1;i&lt;=n;i++)&#123; if(ch[i]=='L') id[i]=idx; else idx=i; &#125; for(int i=n;i&gt;=1;i--)&#123; if(ch[i]=='R') id[i]=idx; else idx=i; &#125; for(int i=1;i&lt;=n;i++)&#123; if(ch[i]=='L')&#123; if((i-id[i])%2==1) ans[id[i]+1]++; else ans[id[i]]++; &#125; else &#123; if((id[i]-i)%2==1) ans[id[i]-1]++; else ans[id[i]]++; &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; cout&lt;&lt;ans[i]&lt;&lt;" "; &#125; return 0;&#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Alyona and Spreadsheet]]></title>
    <url>%2Fvoids3.github.io%2F2019%2F09%2F22%2FAlyona-and-Spreadsheet%2F</url>
    <content type="text"><![CDATA[解题思路： 用二维数组逐个查找会超时，用多个一维数组来表示： a[]存储每一行的值，b[]表示每一列最高能到达的行数,c[]表示每一行的数最高能到达的行数 ；具体看代码。Code: 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;using namespace std;const int N = 1e5+5;int a[N],b[N],c[N];//每一行的值，每一列能到达的最上行，每一行能到达的最上行 int main()&#123; int n,m,x; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=m;i++) b[i]=1;//初始化最上行为1 for(int i=1;i&lt;=n;i++)&#123; c[i]=i; for(int j=1;j&lt;=m;j++)&#123; cin&gt;&gt;x; if(x&lt;a[j]) b[j]=i;//更新每一列最高到达的行数 a[j]=x;//更新一行每列的值 if(c[i]&gt;b[j]) c[i]=b[j];//c表示最高能到达的行数，越小行数越高 &#125; &#125; int k,l,r; cin&gt;&gt;k; while(k--)&#123; cin&gt;&gt;l&gt;&gt;r; if(c[r]&lt;=l)&#123; printf("Yes\n"); &#125; else printf("No\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>cf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[删括号]]></title>
    <url>%2Fvoids3.github.io%2F2019%2F09%2F19%2F%E5%88%A0%E6%8B%AC%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[原题链接：https://ac.nowcoder.com/acm/problem/21303解题思路：用dp[i][j][k]数组，i表示s1前i个字符，j表示s2的前j个字符，k=s1删去的’(‘-s1删去的’)’; 如果s1前i个字符删去k个 ‘(‘ 与s2相符，则令dp[i][j][k]==true，最终只要满足dp[len1-1][len2-1][0]==true,即为Possible Code: 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 200;int dp[N][N][N]; int main()&#123; string ss,tt; cin&gt;&gt;ss&gt;&gt;tt; memset(dp,0,sizeof(dp)); int len1=ss.length(); int len2=tt.length(); dp[0][0][0]=1; for(int i=0;i&lt;len1;i++)&#123; for(int j=0;j&lt;len2;j++)&#123; for(int k=0;k&lt;len1/2;k++)&#123; if(dp[i][j][k])&#123; //当删除恰好为"()",且符合目标状态 if(k==0&amp;&amp;ss[i+1]==tt[j+1]) dp[i+1][j+1][k]=1; //下一字符为"(",差值k+1 if(ss[i+1]=='(') dp[i+1][j][k+1]=1; //凑够(),删去),差值k-1 else if(k) dp[i+1][j][k-1]=1; &#125; &#125; &#125; &#125; if(dp[len1-1][len2-1][0]) printf("Possible\n"); else printf("Impossible\n"); return 0;&#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HNOI2003]操作系统]]></title>
    <url>%2Fvoids3.github.io%2F2019%2F09%2F19%2FHNOI2003-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[题目链接：https://ac.nowcoder.com/acm/problem/20030解题思路：首先建立一个优先队列，队列中元素由优先级从大到小排列，如果优先级相同，则按开始时间从小到大排列 如果队列为空，则向其中添加进程，进程进行过程有以下两种情况 1.j进程可以在i进程开始之前结束，则将j进程从队列踢出并进行输出 2.j进程不能在i进程开始之前结束，则更新j进程的操作时间，然后重新入队 （如果i进程优先级小于等于j进程，由于i的开始时间小于j，故j进程仍比i进程先进行完，但还要比较j进程是否与其他进程的开始时间冲突） Code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;const int N = 1e6+5;struct node &#123; int id,st,ct,pr; friend bool operator &lt; (node a,node b)&#123;//优先队列 if(a.pr==b.pr) return a.st&gt;b.st;//如果优先级相同，返回开始时间小的 else return a.pr&lt;b.pr;//返回优先级大的 &#125;&#125;tt[N];priority_queue&lt;node&gt;q;int main()&#123; int cnt=0; while(~scanf("%d%d%d%d",&amp;tt[cnt].id,&amp;tt[cnt].st,&amp;tt[cnt].ct,&amp;tt[cnt].pr)) cnt++; int i=0; long long now; while(i&lt;cnt)&#123; if(q.empty()) q.push(tt[i]),now=tt[i].st,i++;//队列为空，则向其中添加元素 else &#123; node bb=q.top();q.pop(); if(now+bb.ct&lt;=tt[i].st)&#123;//队顶进程能在下一个进程开始前完成 now+=bb.ct; printf("%d %lld\n",bb.id,now);// q.push(tt[i]);now=tt[i].st;i++; //直接加入不行，但不知道原因 &#125; else &#123; bb.ct=bb.ct-tt[i].st+now;//如果不能完成，则更新队顶进程的操作时间，重新入队 now=tt[i].st; q.push(bb),q.push(tt[i]); i++; &#125; &#125; &#125; while(!q.empty())&#123;//将队列中剩余元素输出 node dd=q.top(); q.pop(); now+=dd.ct; printf("%d %lld\n",dd.id,now); &#125; return 0;&#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[被3整除的子序列]]></title>
    <url>%2Fvoids3.github.io%2F2019%2F09%2F18%2F%E8%A2%AB3%E6%95%B4%E9%99%A4%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[解题思路：1.首先要明白子序列的意思：如qwwweec，（qwe,wec等都是它的子序列）; 2.一个数如果可以被3整除，那么各位数之和也可以被3整除。 3.dp[i][j]表示前i位数子序列的余数为j的个数；（m表示余数，dp[i][j]应该等于dp[i-1][j]+dp[i-1][(j+3-m)%3]的和再模mod）； 令后半部分为dp[i-1][x],所以(x+m)%3=j+3,即x=(j+3-m)%3。 Code: 1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;typedef long long ll;const int mod = 1e9+7;int main()&#123; string ss; cin&gt;&gt;ss; int len = ss.length(); int dp[55][3]; memset(dp,0,sizeof(dp)); dp[0][(ss[0]-'0')%3]=1; for(int i=1;i&lt;len;i++)&#123; int m=(ss[i]-'0')%3;// dp[i][m]=(dp[i][m]+1)%mod; for(int j=0;j&lt;3;j++)&#123; dp[i][j]=(dp[i-1][j]+dp[i-1][(j+3-m)%3])%mod;//dp公式 &#125; dp[i][m]=(dp[i][m]+1)%mod;//初始化时为0，故计算时需加1 &#125; cout&lt;&lt;dp[len-1][0]%mod&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-154]]></title>
    <url>%2Fvoids3.github.io%2F2019%2F09%2F18%2Fleetcode-154%2F</url>
    <content type="text"><![CDATA[反转每对括号间的子串题目链接：https://leetcode-cn.com/problems/reverse-substrings-between-each-pair-of-parentheses/解题思路：未遇到右括号前就压栈，遇到右括号后就反转最近的左括号与右括号之间的元素，最后需要反转输出 反转括号间的元素可以用栈来操作，先出栈再入栈。 Code: 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: string reverseParentheses(string s) &#123; string ss; ss=s; stack&lt;char&gt;s1; int len = ss.length(); for(int i=0;i&lt;len;i++)&#123; if(ss[i]==')')&#123; string ch=""; while(s1.top()!='(')&#123; ch+=s1.top(); s1.pop(); &#125; s1.pop(); for(int j=0;j&lt;ch.length();j++)&#123; s1.push(ch[j]); &#125; &#125; else &#123; s1.push(ss[i]); &#125; &#125; string tt=""; while(!s1.empty())&#123; tt+=s1.top(); s1.pop(); &#125; reverse(tt.begin(),tt.end()); return tt; &#125;&#125;; K次串联后最大子数组之和 题目链接：https://leetcode-cn.com/problems/k-concatenation-maximum-sum/ 解题思路：lmax表示单个数组的最大前缀和，rmax表示单个数组的最大后缀和，maxx表示单个数组最大连续和,sum表示单个数组总和 1.如果n==1;返回maxx即可 2.如果n&gt;1;如果sum&gt;=0;比较maxx与sum*(k-2)+lmax+rmax. 如果sum&lt;0;比较maxx与lmax+rmax. Code: 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: int kConcatenationMaxSum(vector&lt;int&gt;&amp; arr, int k) &#123; typedef long long ll; long long mod=1e9+7; ll lmax=0,rmax=0; ll cur=0; int n=arr.size(); for(int i=0;i&lt;n;i++)&#123; cur+=arr[i]; lmax=max(lmax,cur); &#125; cur=0; for(int i=n-1;i&gt;=0;i--)&#123; cur+=arr[i]; rmax=max(rmax,cur); &#125; //最大连续和 ll maxx=0,sum=0; cur=0; for(int i=0;i&lt;n;i++)&#123; sum+=arr[i]; cur+=arr[i]; if(cur&lt;0) cur=0; maxx=max(maxx,cur); &#125; if(k==1) return maxx%mod; else&#123; //sum&gt;=0 maxx=max(maxx,lmax+rmax+(k-2)*sum); //sum&lt;0 maxx=max(maxx,lmax+rmax); return maxx%mod; &#125; &#125;&#125;;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Minimum Sum LCM]]></title>
    <url>%2Fvoids3.github.io%2F2019%2F09%2F14%2FMinimum-Sum-LCM%2F</url>
    <content type="text"><![CDATA[解题思路： 首先需要知道分解质因数的知识，其次需要注意到两个点。 1.如果n为质数或为1，因为求lcm最少需要两个数，所以结果应为n+1. 2.如果一个数有多个相同的质因子，应将他们相乘后再相加，如4，8；他们的结果应为质因子相乘后再加1. Code： 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;map&gt;using namespace std;typedef long long ll; int main()&#123; ll n,k=1; while(~scanf("%lld",&amp;n)&amp;&amp;n)&#123; ll ans=0; vector&lt;ll&gt;ve; map&lt;ll,ll&gt;ma; for(ll i=2;i*i&lt;=n;i++)&#123; if(n%i==0)&#123; ve.push_back(i); &#125; while(n%i==0)&#123; ma[i]++; n/=i; &#125; &#125; if(!ve.size())&#123;//ve.size()==0,说明n为质数 ans=n+1; &#125; else &#123; if(ve.size()==1 || n!=1)//如果ve.size()==1,说明只有一个相同的质因子，此时n==1,应加上n ans += n;//如果n!=1且ve.size()&gt;1,此时n&gt;1，根据唯一分解定理，应加上n for(ll i=0;i&lt;ve.size();i++)&#123; ans += pow(ve[i],ma[ve[i]]); &#125; &#125; printf("Case %lld: %lld\n",k++,ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>唯一分解定理</tag>
      </tags>
  </entry>
</search>
